/* vim: set ft=txt shiftwidth=2 tabstop=2 expandtab: */

PHPTAL - PHP Template Attribute Language
Author: Laurent Bedubourg <lbedubourg@motion-twin.com>
Date: 2004-12-22


ABOUT
*****

  PHPTAL is an implementation of the excellent Zope Page Template (ZPT) 
  system for PHP. PHPTAL supports TAL, METAL, I18N namespaces.
  
  PHPTALES is the equivalent of TALES, the Template Attribute Language 
  Expression Syntax, it defines how are handled xml attribute values.  

  As PHPTALES is near TALES, it should be easy to port python TAL 
  templates to PHP ones (and reverse).

  To be TAL compliant, PHPTAL implements an XPATH like access to data.

  PHPTAL is freely distributed under the LGPL license, it is developped 
  and maintained by Laurent Bedubourg (lbedubourg@motion-twin.com).

  This document is a first documentation about PHPTAL usage for both php
  developpers and template designers. It's not complete yet as i 
  certainly forgot a lot of things, please send me requests and notes.  
  And 'please' be patient with my style, i'm not a natural english 
  speaker.


WHY YOU SHOULD USE PHPTAL
*************************
  
  XML/HTML templates exists to separate logic from presentation in web 
  services. This separation brings more than one benefits in its 
  luggage.

  - better application design
  - easier task repartition
  - better maintainability
  - easy web skins

  Most template systems uses <? ?>, <% %> or <xxx:yyy></xxx:yyy> tags to 
  find their marks. It allow easier template system development but that 
  doesn't really help template designers.

  The idea behind TAL is to allow WYSIWYG template edition with sample 
  rendering without stranges tags everywhere. That's why TAL work on xml 
  attributes in stead of markup tags.

  If you already worked with a simple template system, you must have 
  encoutered something looking like :
  
    <table>
      <%loop myarray as myitem %>
      <tr> 
        <td><% myitem %></td>
      </tr>
      <%/loop%> 
    </table>

  Well with phptal you now can do :

    <table> 
      <tr tal:repeat="myitem myarray">
        <td tal:content="myitem">
          text replaced by the item value
        </td>
        <td tal:replace="">sample 1</td> 
        <td tal:replace="">sample 2</td> 
        <td tal:replace="">sample 3</td> 
      </tr> 
    </table>
  
  In WYSIWYG mode, the above code will render correctly with samples 
  text and you can present it to your clients even if the code required 
  to get 'myarray' values doesn't exist yet.

  Another big advantage of PHPTAL is that you benefit from more than 3 
  years of ZOPE community experiences, documentation, examples, help.  
  PHPTAL rely on this community to provide its users a great amount of 
  knowledge.

  PHPTAL is designed to be as customizable as possible for advanced 
  developpers and performance eaters systems but still easy to use for 
  beginers with a comfortable and simple default behaviour.


FIRST EXAMPLE
*************
  
  To get a first impression about PHPTAL usage, a simple example is better 
  than many words.

  Your template is a valid xml/html document (with a root element). Here's 
  a file named 'my_template_file.html'.
  
    <?xml version="1.0"?> 
    <html>
      <head>
        <title tal:content="title">
          place for the page title
        </title>
      </head>
      <body>
        <h1 tal:content="title">sample title</h1>
        <table>
          <tr>
            <td>name</td>
            <td>phone</td>
          </tr>
          <tr tal:repeat="item result">
            <td tal:content="item/name">item name</td>
            <td tal:content="item/phone">item phone</td>
          </tr>
          <tr tal:replace=""> 
            <td>sample name</td>
            <td>sample phone</td>
          </tr>
          <tr tal:replace="">
            <td>sample name</td>
            <td>sample phone</td>
          </tr>
        </table>
      </body> 
    </html>

  In php, you just have to include the PHPTAL library and maybe 
  configure a few variables to customize the template system.

    <?php 
    require_once 'PHPTAL.php';

    // create a new template object 
    $template = new PHPTAL('my_template_file.html');

    // the Person class 
    class Person { 
      var $name; 
      var $phone;
    
      function Person($name, $phone) 
      { 
        $this->name = $name; 
        $this->phone = $phone; 
      } 
    }

    // let's create an array of objects for test purpose 
    $result = array(); 
    $result[] = new Person("foo", "01-344-121-021"); 
    $result[] = new Person("bar", "05-999-165-541"); 
    $result[] = new Person("baz", "01-389-321-024"); 
    $result[] = new Person("buz", "05-321-378-654");

    // put some data into the template context
    $template->title = 'the title value';
    $template->result = $result;

    // execute the template 
    try {
      echo $template->execute(); 
    }
    catch (Exception $e){
      echo $e;
    }
    ?>

  If you execute the php script, you will obtain something similar to 
  what follows.

    <?xml version="1.0"?> 
    <html>
      <head>
        <title>the title value</title>
      </head>
      <body>
        <h1>the title value</h1>
        <table> 
        <tr>
          <td>name</td>
          <td>phone</td>
        </tr>
        <tr>
          <td>foo</td>
          <td>01-344-121-021</td>
        </tr><tr> <td>bar</td>
          <td>05-999-165-541</td>
        </tr><tr> <td>baz</td>
          <td>01-389-321-024</td>
        </tr><tr> <td>buz</td>
          <td>05-321-378-654</td>
        </tr>
        </table>
      </body>
    </html>

  Well, i assume you don't mind 'too' much about cariage returns in the 
  html code :) If so, you may use the tidy functions to cleanup the 
  resulting html before echoing it.


INSTALLATION
************

  PHPTAL is released as a PEAR package (see http://pear.php.net).
  You can download it on the PHPTAL website (http://phptal.sf.net) 
  folowing the resources link.

  After downloading the package, you can install it using the pear 
  utility :
 
    pear install PHPTAL-X.X.X.tar.gz

  If you do not use PEAR or does not have it installed on your system, 
  you still can install PHPTAL unzipping the downloaded archive. Move 
  the PHPTAL.php file in your library folder, create a PHPTAL folder in 
  your library folder then copy all remaining files in this newly 
  created folder.

    tar zxvf PHPTAL-X.X.X.tar.gz
    mv PHPTAL-X.X.X PHPTAL
    mv PHPTAL/PHPTAL.php /path/to/your/include/path
    mv PHPTAL /path/to/your/include/path


TEMPLATE LANGUAGE
*****************

  TAL namespace
  =============

  tal:define
  ----------
  
  This attribute defines one or more variables which may be used later 
  in the template.

  Making a shortcut to a long path :
  
    <span tal:define="destname path/to/existing/variable" />

  Creating a string inside the template :

    <span tal:define="destname string:some string" />

  Creating an array :

    <span tal:define="destname array:1, 2, 3, 4" />

  Defining more than one variables at the same time :

    <span tal:define="fname string:paul; lname string:dupond" />

  Defining a string containing another variable :
  
    <span tal:define="hello string:hello $fname welcome on this page" />


  tal:condition
  -------------

  The entity and its content will be shown only if the condition is 
  evaluated to true.

    <span tal:condition="identified"> 
      Welcome member ... 
    </span>

    <span tal:condition="not: identified"> 
      Please login before accessing this page 
    </span>


  tal:repeat
  ----------

  This attribute handles iterable objects like array, associative 
  arrays, and objects implementing the PHP5 Iterable class (see Iterable 
  chapter).

  The repeat attribute repeat it's entity and its content until the end 
  of the specified resource.

    <tr tal:repeat="item some/result"> 
      <td tal:content="item">text replaced by item</td> 
    </tr>

  Within a loop, you can access current loop (and parent for imbriqued 
  loops) information using specific repeat/* pathes.

  In the above example : 

  - repeat/item/index  : return the item index (0 to count-1)
  - repeat/item/number : returns the item number (1 to count)
  - repeat/item/even   : returns true if item index is pair
  - repeat/item/odd    : returns true if item index is impair
  - repeat/item/start  : returns true if item is the first one 
  - repeat/item/end    : returns true if item is the last one 
  - repeat/item/length : returns the number of elements in some/result 
  - repeat/item/key    : returns the item's key if some/result is an associative 
                         resource (index otherwise)

  "item" depends of the receiver variable defined in tal:repeat expression.


  tal:omit-tag
  ------------

  This attribute ask PHPTAL parser to ignore the entity's head and foot, 
  it's content will still be evaluated.

    <span tal:omit-tag="">
      only this text will appear, span open and close will be removed 
    </span>

  Will produce :

    only this text will appear, span open and close will be removed

  This attribute is usefull when you want to define a macro, a loop, a 
  condition, or any other template logic that mustn't show it's root 
  tag.


  tal:replace
  -----------

  This attribute will replace the entire tag with a value or by nothing 
  if no value is given.

    <span tal:replace="string:this beautyfull string"> 
      this uggly string and span 
    </span>

  Will produce :

    this beautyfull string 

  tal:replace can also be used to create samples in source templates and 
  remove them from final output.

    <table> 
      <tr tal:repeat="item myresult">
        <td tal:content="item">item value</td>
      </tr> 
      <tr tal:replace="">
        <td>sample 1</td>
      </tr>
      <tr tal:replace="">
        <td>sample 2</td> 
      </tr> 
    </table>


  tal:content
  -----------

  This attribute replace the tag content with the evaluation of its 
  expression.

    <span tal:define="myvar string:my string"/> 
    <span tal:content="myvar">will be replaced</span>

  Will produce :

    <span>my string</span>


  tal:comment
  -----------

  This attribute has no effect but can help template designers 
  commenting their work.

    <tr tal:comment="Loop over the person database result"
        tal:repeat="person persons"> 
      <td tal:content="person/id">person id here</td> 
    </tr>


  tal:attributes
  --------------

  This attribute change tag attribute(s) value(s).

    <a href="http://www.foo.com" title="some foo link" 
       tal:attributes="href somelink/href; title somelink/title" 
       tal:content="somelink/text" >sample link</a>

  With a 'somelink' having :

    $somelink->href = "http://www.google.com"; 
    $somelink->title = "google search engine"; 
    $somelink->text = "the google search engine";

  Will produce :

    <a href="http://www.google.com" 
       title="google search engine">the google search engine</a>

  
  tal:on-error
  ------------

  This attribute replace the tag by the tal:on-error expression 
  evaluation if a path error is detected in the tag content or if any 
  php exception is thrown in the tag content.

    <span tal:on-error="string:No username defined here"     
          tal:content="user/name">the user name here</span>

  If an error occurs accessing 'name' or 'user', the error string will 
  be shown at the tag place.

  This also works on more than one level of template :

    <span tal:on-error="string:error occured somewhere"> 
      <span tal:content="user/firstname"/> 
      <span tal:content="user/lastname"/> 
    </span>


  METAL namespace
  ===============

  METAL stands for 'Macro Extension for TAL'. This namespace, supported 
  by PHPTAL allow template designers to define and call xml/xhtml 
  macros.

  
  metal:define-macro
  ------------------

  This attribute declare a macro. Think of macros as library of small 
  templates which can be reused in any other template. 

    <div metal:define-macro="main_menu"> 
      <ul>
        <li><a href="/">home</a></li>
        <li><a href="/products">products</a></li>
        <li><a href="/contact">contact</a></li>
      </ul>

      <div>
      Last modified : 
      <span tal:content="mdate">page modification date</span> </div>
    </div>

  Macros inherit from caller dictionnary. In the above example, the 
  variable 'mdate' depends on the template that calls the macro.


  metal:use-macro
  ---------------

  This attribute calls a macro and include its result in the current 
  template.

    <span 
      tal:comment="main_menu template requires 'mdate' variable"
      tal:define="mdate page/last_modified" /> 
    <span metal:use-macro="main_menu" />

  You can refer external macros defined in other templates specifying 
  the template source file.

    <span use-macro="site_macros.html/main_menu"/>


  metal:define-slot
  -----------------

  This attribute must appear under a metal:define-macro tag.

  Slots can be replaced by caller template with some custom dynamically 
  generated XML/XHTML.

  Slots can be thinked of like reverse includes, a macro can be an 
  entire page and slots customize this page depending on the URL. For 
  instance, a slot may contains latest news in the home page and user 
  actions when the member is logged.

    <span metal:define-slot="news_place"> 
    <table>
      <tr tal:repeat="item php:latestNews()">
        <td tal:content="item/value">news description</td> 
      </tr>
    </table>
    </span>

  The above example defines a place called 
  '<emphasis>news_place</emphasis>' which can be overwritten by caller 
  templates. See next section for the continuation of this example.

  
  metal:fill-slot
  ---------------

  This attribute occurs only under metal:use-macro context.

  This explicitely tells PHPTAL to replace defined slot with the content 
  provided under the metal:fill-slot attribute.

    <span tal:condition="logged" metal:fill-slot="news_place">   
      <h2>user menu</h2>
      <ul>
        <li><a href="/user/action/inbox">inbox</a></li>
        <li><a href="/user/action/new">new mail</a></li>
        <li><a href="/user/action/disconnect">disconnect</a></li>
      </ul>
    </span>

  Slots give the opportunity to define really customizable and reusable 
  page templates with a simple push technology.


  I18N namespace
  ==============

  Note: 'i18n' is a short name for 'internationalisation', this 
  namespace allow template designers to specify some text zones that 
  must be translated during template evaluation.


  i18n:translate
  --------------

  This attribute define some text part that must be translated using 
  PHPTAL translation system.

    <div i18n:translate="string:welcome_message">Welcome here</div>

  In the above example, PHPTAL will looks for a translation key named
  'welcome_message' and will replace the content of the tag with the 
  equivalent in current requested language.

    <div i18n:translate="">Welcome here</div>

  This usage is a little different, no translation key is given, thus, 
  PHPTAL will use the content of the tag 'Welcome here' as the 
  translation key.  This is a regular translation usage if translation 
  system knows the key 'Welcome here'.

  If no translation is found, the key will be used as the translation 
  result. That's why using readable message in stead of keys may be a 
  good choice.

  Please note that the key to translate may be contained in a variable 
  to allow dynamic key selection.

    <div tal:define="welcome random_welcome_message"/>
    <did i18n:translate="welcome">...</div>


  i18n:name
  ---------

  This attribute set a translation variable value.

  Translations may contains ${xxx} strings where "xxx" is the name of a 
  variable that need to be interpolated dynamically.

  The value of this variable will be set to the tag and its content, if 
  you doesn't need tag around the value, use tal:replace instead of 
  tal:content, tal:omit-tag may help if the value is a concatenation of 
  strings.

    <span i18n:name="myVar" tal:content="some/path"/> 
    <!-- <span>${some/path}</span> -->

    <span i18n:name="myVar" tal:replace="some/path"/> 
    <!-- ${some/path} -->

    <span i18n:name="myVar">foo</span> 
    <!-- <span>foo</span> -->

    <span i18n:name="myVar" tal:omit-tag="">foo</span> 
    <!-- foo -->

  An exemple of i18n usage:

    <div i18n:translate="">
      Welcome <span i18n:name="user" tal:replace="user/name"/>, 
      you have <span i18n:name="mails" tal:replace="user/nbrMails"/> 
      unreaded mails. 
    </div>

  The translation key of this example will be :

    "Welcome ${user}, you have ${mails} unreaded mails."

  PHPTAL will replace ${user} with ${user/name} and ${mails} with 
  ${user/nbrMails} in translation.

  
  PHPTAL namespace
  ================

  These attributes are not defined in TAL specifications but are usefull 
  when working with PHPTAL.


  phptal:debug
  ------------

  This attribute toggle activate PHPTAL debuging for the content of the 
  tag it is defined in.

  The debug mode stores information like filename and source line number 
  in the template so exceptions thrown by incorrect path access will 
  contains more information about where they where thrown.

    <html>
      <head>
         ...
      </head>
      <body>
        <div id="menu">
          ...
        </div>
        <div 
          id="leftPane" 
          tal:comment="this div seems buggy, keep trace of where errors are thrown"
          phptal:debug="">
          ...
        </div>
      </body>
    </html>

  
  phptal:tales
  ------------

  This attribute allow use to change the beaviour of PHPTALES. The 
  default behaviour is to interpret attribute expressions in a very ZPT 
  way. But sometimes you just would like to have PHP there and you end 
  up using php: modifier everywhere (read chapter about PHPTALES).

  Another problem concerning PHPTALES is the way PHPTAL have to 
  interpret pathes. For exemple, 
  myobject/mymethod/10/othermethod/hashkey is very long to interpret. 
  
  PHPTAL has to (at runtime) take myobject, see that it is an object, 
  find if 'mymethod' is a variable of this object or a method of the 
  object, then call it, explore the result to determine if it is an 
  array, find the tens element of this array, determine if it is an 
  object and decide if othermethod is a variable or a method of this 
  object then get the result of this execution, find that it is an 
  associative array and retrieve the value for the key 'hashkey'.

  Of course this was an extreme exemple and most of the time we don't 
  care because the process is fast enough. But what if this very long 
  path is called inside a big tal:repeat ? dohh ! phptal:tales can help 
  us there :

    <html>
      <body>
        <table phptal:tales="php">
          <tr tal:repeat="myobject document.getChildren()">
            <td tal:content="myobject.mymethod()[10].otherMethod()['hashkey']"></td>
          </tr>
        </table>
      </body>
    </html>

  Well, i am not sure the exemple above compiles but you get the idea of 
  what you can do with phptal:tales. All tal, metal, i18n pathes will be 
  plain PHP expressions.

  Please note that the above example do the same as :
  
    <html>
      <body>
        <table>
          <tr tal:repeat="myobject php:document.getChildren()">
            <td 
          tal:content="php:myobject.mymethod()[10].otherMethod()['hashkey']"></td>
          </tr>
        </table>
      </body>
    </html>

  'php:' is explained in its own chapter.


  *:BLOCK
  =======

  :block is a syntax sugar for elements which contains many tal 
  attributes and which are not to be echoed. 

    <tal:block define="myvar string:Some value"/>

  is the same as :

    <span tal:define="myvar string:Some value"/>

  Another example :

    <tal:block condition="someCondition" repeat="item someRepeat">
      <div metal:use-macro="x"/>
    </tal:block>

  is the same as :

    <div tal:omit-tag="" 
        tal:condition="someCondition" 
        tal:repeat="item someRepeat">
      <div metal:use-macro="x"/>
    </div>


PHPTALES
********

  PHPTALES is the expression syntax used inside tal, metal, phptal 
  attributes. From above exemples, you should have seen some of PHPTALES 
  examples (string:, php:, not:, ...). This chapter describe the usage 
  of PHPTALES in templates.

  The value of a TAL attribute may contain more than one expression (ex:
  tal:define), in which case each expression must be separated from the
  next one with a ';' character.

  Path
  ----

  Inside the template or inside expression strings, you can refer to a 
  context variable using its path in the form ${path/to/my/variable}

    <h1>${document/title}</h1>
    <span tal:replace="string:welcome ${user/name}, 
          this page has been readed ${page/countRead} times"/> 


  Conditional statements
  ----------------------

  As '<' and '>' should be removed from attribute expression, PHPTAL 
  provides some good old text equivalent comparision operators.

  These statements will mostly appear in tal:condition attributes, and 
  in php: expressions.

    - < : LT (less than)
    - > : GT (greater than)
    - <= : LE (less or equal)
    - >= : GE (greater or equal)


  string:
  -------

  As expressions are separated by a ';' character, and as '$' marks the 
  start of a path, you must use

  - ';;' when you want to insert a real ';' character in a string,
  - '$$' when you want to insert a real '$' character in a string.

    <span tal:replace="string:this is a $$100 page"/>
    string:foo $bar baz       <!-- will replace $bar --> 
    string:foo $$bar baz      <!-- no interpolation --> 
    string:foo ; php:doFoo()  <!-- two different expressions --> 
    string:foo ;; php:doFoo() <!-- only string -->


  php:
  ----

  This expression evaluate what follows as a regular php expression 
  except that '-&gt;' are replaced by dots '.' and variable names does 
  not need to be prefixed with a dollar '$' sign.

  A dot '.' separated from the rest of expression by spaces is assumed 
  to be a concatenation sign.

    php:htmlentities(foo)
    php:'string $varReplaced'
    php:'string ${some/path/to/var}'
    php:NOT foo OR (bar GT baz)
    php:a + b
    php:array('a', 'b', 'c')
    php:range(0, 90)
    php:foo . a.b.c(e) . htmlentities(SomeClass::staticMethod()) 

  php: should be used with care and won't be needed in 80% of your 
  templates but some times you will need to invoke some php special 
  method to be sure a user is logged or to retrieve a specific heavy 
  data depending on some conditions and dynamically inside the template.

  
  not:
  ----

  This expression is a boolean one, usefull in tal:condition statements. 

    <span tal:condition="not: logged">not logged</span>


  exists:
  -------

  This expression is a boolean expression, it will returns true if the 
  path specified after it exists of not.

    <span tal:condition="exists: user/preferences"    
          tal:content="user/preferences"> 
      user preferences here if defined 
    </span>

  It is important to keep in mind that using a path which doesn't exists 
  will throw and exception. Thus, uncertain pathes must be checked 
  first.


  default
  -------

  This is not an expression but a keyword allowing template designers to 
  keep the content of a tag as an alternative value if an error occurs 
  or if something is not defined.

    <span tal:define="myVar path/to/possible/var | default"> 
      default my var value 
    </span>

    <span tal:content="some/var | other/path | default"> 
      no some/var and no other/path found here 
    </span>

    <a href="unknown.html" title="Unknown page"
       tal:attributes="href item/href | default;
                       title item/title | default"
       tal:content="item/title | default">Unknown page</a>

  Above examples introduce the '|' characters that allow the definition 
  of alternatives for defines or prints. See next paragraph.


  structure
  ---------

  This is not an expression but a keyword.

  While printing variables inside PHPTAL templates, you certainly have 
  remarked that PHPTAL encode each variable to ensure the validity of 
  the output document. 
 
  Sometimes, you may use HTML/XML variables that must be echoed as is.

    <h1 tal:content="structure document/title"/> 
    <span tal:replace="structure document/content"/>

  In above examples, we assume that $document->title and 
  $document->content are variables containing preformated html that must 
  be echoed as is.


  Expression chains
  -----------------

  A chain of expression is a list of expressions separated by '|' 
  character.

  While evaluating expressions separated by '|', PHPTAL will stop its 
  evaluation when an expression value is not null and no error was 
  raised while evaluating the expression.

  As a string: expression is always true, string: always terminate an 
  expression chain whatever expression may follows. 

  You can use php: expressions inside expression chains as any other 
  expression.

    <h1 tal:content="page/title | page/alterNativeTitle | default>
      untitled page
    </h1>


PHP INTEGRATION
***************

  This section targets PHP developpers and explain how to use and 
  customize PHPTAL behavious for simple and advanced usage.

  - Defines : list of PHPTAL defines and defines influencing PHPTAL
  - PHPTAL : the main PHPTAL class
  - PHPTAL_Filter  : filtering template sources and PHPTAL output
  - PHPTAL_Trigger : creating triggers for phptal:id
  - PHPTAL_TranslationService : replacing the builtin gettext support 
    with your own internationalization system

  Defines
  =======

  After the inclusion of PHPTAL library, some defines will be created in 
  PHP context, all these defines comes from PHPTAL.php file :

  - PHPTAL_VERSION : version of PHPTAL library installed on your system 
    (in format : X.X.X) 
  - PHPTAL_PHP_CODE_DESTINATION : this is the path where intermediate 
    PHP files produced by PHPTAL will be stored. This define may be 
    overwritten before the inclusion of PHPTAL.php, the specified path 
    must contain the leading path separator.

  You can configure some PHPTAL features defining some constants :

  To tell PHPTAL to ignore intermediate php files and to reparse 
  templates everytime :

    <?php
    define('PHPTAL_FORCE_REPARSE', 1);
    require_once 'PHPTAL.php';
    ?>
  
  To tell PHPTAL to store its intermediate PHP files otherwhere than in 
  the '/tmp/' directory :

    <?php
    define('PHPTAL_PHP_CODE_DESTINATION', '/path/to/somewhere/');
    require_once 'PHPTAL.php';
    ?>

  If all your files are stored in a base directory (repository), you can 
  define PHPTAL_TEMPLATE_REPOSITORY as follow :

    <?php
    define('PHPTAL_TEMPLATE_REPOSITORY', '/path/to/templates/root');
    require_once 'PHPTAL.php';
    ?>

  This doesn't mean all your files need to be in the root directory, you 
  can use sub folders to organize your template designers work. It's 
  just a shortcut which will allow you to reference templates without 
  specifying the real path but their relative path in the repository.


  class PHPTAL
  ============

  This is the main class that allow you to interact with PHPTAL. Here 
  are presented main PHPTAL methods. More methods will be explained in 
  'interfaces' chapters as their usage is related to these interfaces.


  interface PHPTAL_Filter
  =======================

  This interface allow you to automatically filter templates sources 
  (pre-filters) or PHPTAL result (post-filters).

  Pre filters are invoked before the template parsing and won't be 
  invoked until the source template file is modified.

  Post filters are invoked after each template execution.

    <?php
    require_once 'PHPTAL.php';
    
    class MyPreFilter implements PHPTAL_Filter {
        public function filter($source){
            return $source;
        }
    }

    class MyPostFilter implements PHPTAL_Filter {
        public function filter($xhtml){
            return $xhtml;
        }
    }

    $tpl = new PHPTAL('mytemplate.html');
    $tpl->setPreFilter(new MyPreFilter());
    $tpl->setPostFilter(new MyPostFilter());
    echo $tpl->execute();
    ?>

  You can set only one pre-Filter and one post-Filter using set*Filter.
  If you have more than one filters to chain, you can wrap them
  into a single class, implementing the PHPTAL_Filter interface, which
  would invoque the filters' chain.

    <?php
    require_once 'PHPTAL.php';

    class FilterChain implements PHPTAL_Filter {
        private $_filters = array();
        
        public function add(PHPTAL_Filter $filter){
            $this->_filters[] = $filter;
        }
        
        public function filter($source){
            foreach ($this->_filters as $filter){
                $source = $filter->filter($source);
            }
            return $source;
        }
    }

    $myfilter = new FilterChain();
    $myfilter->add(new CommentFilter());  // imaginary filter
    $myfilter->add(new TidyFilter());     // imaginary filter
    
    $tpl = new PHPTAL('mytemplate.html');
    $tpl->setPostFilter($myFilter);
    echo $tpl->execute();
    ?>
    

  interface PHPTAL_Trigger
  ========================

  The phptal:id attribute was added into the PHPTAL for PHP5 version to 
  replace the old PHPTAL_Cache interface and abstract it a little more.

  When a phptal:id is reached, PHPTAL will look in its triggers list
  for a matching id and will invoke the trigger start() and end() 
  methods before entering the element and just after it.

  If the PHPTAL_Trigger::start() methods returns 
  PHPTAL_Trigger::SKIPTAG, PHPTAL will ignore the element and its 
  content (start() may echo something to replace it).

  If your trigger want the element and its content to be executed, 
  you'll have to return PHPTAL_Trigger::PROCEED.

  The PHPTAL_Trigger::end() will be called after the element (whether it 
  has been executed or not). This allows you to build cache systems
  using ob_start() in start() and ob_get_contents(), ob_end_clean() in 
  end().

    <html>
      ...
      <div>
      ...
      foo bar baz <span tal:replace="id"/> foo bar baz
      ...
      </div>
      ...
    </html>

  For some reason we decide the div block requires to be cached, we introduce
  a phptal:id into the template :
  
    <html>
      ...
      <div phptal:id="somePossiblyUniqueKeyword">
      ...
      foo bar baz <span tal:replace="id"/> foo bar baz
      ...
      </div>
      ...
    </html>
  
  Then we write our trigger which will have to cache the div content:
  
    <?php
    require_once 'PHPTAL.php';
    require_once 'PHPTAL/Trigger.php';

    class CacheTrigger implements PHPTAL_Trigger
    {
        public function start($phptalid, $tpl)
        {
            // this cache depends on 'id' which must appears in
            // the template execution context
            $this->_cachePath = 'cache.' . $tpl->getContext()->id;

            // if already cached, read the cache and tell PHPTAL to
            // ignore the tag content
            if (file_exists($this->_cachePath)){
                $this->_usedCache = true;
                readfile($this->_cachePath);
                return self::SKIPTAG;
            }
        
            // no cache found, we start an output buffer and tell
            // PHPTAL to proceed (ie: execute the tag content)
            $this->_usedCache = false;
            ob_start();
            return self::PROCEED;
        }

        // Invoked after tag execution
        public function end($phptalid, $tpl)
        {
            // end of tag, if cached file used, do nothing
            if ($this->_usedCache){
                return;
            }

            // otherwise, get the content of the output buffer
            // and write it into the cache file for later usage
            $content = ob_get_contents();
            ob_end_clean();
            echo $content;

            $f = fopen($this->_cachePath, 'w');
            fwrite($f, $content);
            fclose($f);
        }
        
        private $_cachePath;
        private $_usedCache;
    }
    ?>
    
  The key here is to reply to start() with either SKIPTAG or PROCEED.
  
  When SKIPTAG is returned, PHPTAL will just ignore the tag and call end(). 
  It usually means that the trigger takes the hand and decide what to show
  there.
  
  When PROCEED is returned, PHPTAL will execute the tag and its content
  as usual then call end(). This allow our cache class to play with output 
  buffers to execute the tag once and store the result into a file which will
  be used in later calls.

  To install our trigger we use :

    <?php
    require_once 'PHPTAL.php';
    require_once 'CacheTrigger.php'; // our custom trigger
    
    $trigger = new CacheTrigger();
    
    $tpl = new PHPTAL('test.html');
    
    // this trigger will only be called for phptal:id="triggerId"
    $tpl->addTrigger('somePossiblyUniqueKeyword', $trigger);
    
    $tpl->id = 1;
    
    echo $tpl->execute();
    
    ?>
    
  You can add as many triggers as you like to your templates. A generic cache
  trigger may also handle more than one phptal:id... etc...
  

  interface PHPTAL_TranslationService
  ===================================

  PHPTAL comes with a default gettext translation service as shown in another
  section. For some reason you may prefer to implement your own service of
  translation.
  
  The PHPTAL_TranslationService interface is here to serves your need.
  
  The usage of your service will be the same as the PHPTAL_GetTextTranslator.
  
    $tpl->setTranslator($yourOwnTranslatorInstance);
  
  Your implementation must define the following methods :
  
  
  method setLanguage(...)
  -----------------------

  This method may be called by the template to change the current ouput
  language.
  
  It's arguments are a list of possible language (use func_get_args() to
  get the argument array). The first known language should be used by your
  service.
  
    <?php
    require_once 'PHPTAL/TranslationService.php';
    
    class MyTranslator implements PHPTAL_TranslationService {
      ...
      public function setLanguage(){
        $langs = func_get_args();
        foreach ($langs as $lang){
           // if $lang known use it and stop the loop
           $this->_currentLang = $lang;
           return;
        }
      }
      ...
      private $_currentLang;
    }
    ?>


  method useDomain($domain)
  -------------------------

  If you decided to store your translations into separated files, one for
  each application for example, this method allow you to select the 
  translation domain from your templates (i18n:domain).
  
    <?php
    require_once 'PHPTAL/TranslationService.php';
    
    class MyTranslator implements PHPTAL_TranslationService {
      ...
      public function useDomain($domain){
        if (!array_key_exists($domain, $this->_domains)){
          $file = "domains/$this->_currentLang/$domain.php";
          $this->_domains[$domain] = include($file);
        }
        $this->_currentDomain = $this->_domains[$domain];
      }
      ...
      private $_currentDomain;
      private $_domains = array();
    }
    ?>
    
  The above example is a possible translation solution where keys are stored
  into php files which returns a associative array of key => translation.
  
  
  method setVar($key,$value)
  --------------------------
  
  This method matches i18n:name calls. It builds an interpollation context
  for later translate calls.
  
    <?php
    require_once 'PHPTAL/TranslationService.php';
    
    class MyTranslator implements PHPTAL_TranslationService {
      ...
      public function setVar($key, $value){
        $this->_context[$key] = $value;
      }
      ...
      private $_context = array();
    }
    ?>
    
    
  method translate($key)
  ----------------------

  The last and most important method to implement, it ask your service to
  translate the specified key for the current selected language.
  
    <?php
    require_once 'PHPTAL/TranslationService.php';
    
    class MyTranslator implements PHPTAL_TranslationService {
      ...
      public function translate($key){
        $value = $this->_currentDomain[$key];
        
        // interpolate ${myvar} using context associative array
        while (preg_match('/\${(.*?)\}/sm', $value, $m)){
          list($src,$var) = $m;
          if (!array_key_exists($var, $this->_context)){
              $err = sprintf('Interpolation error, var "%s" not set', $var);
              throw new Exception($err);
          }
          $value = str_replace($src, $this->_context[$var], $value);
        }
        
        return $value;
      }
      ...
    }
    ?>
    

Creating custom expression modifiers
====================================

PHPTAL comes with some basic expression modifiers (not:, exists:, string:,
php:, path:).

These modifiers are defined by ZPT specifications but PHPTALES can be
extended with your own modifiers to manipulate strings, date, money numbers,
objects, whatever...

The aim of a modifier is to return some PHP code that will be included in
the template php source.

Modifiers are used at parse time, if you change the behaviour of a
modifier, you'll have to delete generated php files. 

Please note that modifiers produced code mustn't echo data !

Any php function starting with "phptal_tales_" is usuable as a modifier.

Modifiers takes two arguments:
- $src : the source string after the "modifier:" keyword
- $nothrow : a boolean which tells if exceptions may be thrown or not by
  phptal_path() resolution. This boolean must be propagated whenever you
  call another phptal_tales_* modifier in your own modifier

For example, in the following TAL template,

    <span tal:replace="some-modifier: my/path/value"/>

The src argument will be "my/path/value" and the $nothrow boolean will be
false because tal:replace requires the path to be fully resolvable.

An expression like :

    <span tal:replace="some-modifier: my/path/value | other/path"/>

Will use 2 modifiers :

  - some-modifier: with "my/path/value" as $src argument and $nothrow set to 
  true because an alternative exists
  - path: with "other/path" as $src and $nothrow set to false, because in 
  case the alternative is not found, tal:replace will be in trouble.

Please note that path: is the implicit modifier used when no other modifier 
is specified.

Modifiers can use other modifiers to generate sub php code. The below exemple
show this.

    //
    // This modifier will return a money formated string (XXX.XX)
    //
    // usage :
    //
    //      money: path/to/my/amount
    //
    // this modifier use phptal_tales_path (path:) modifier to generate the
    // php code that will return the value of the modifier argument.
    //
    // in the example :
    //
    //      money: path/to/my/amount 
    // 
    // the expression "virtually" became money: path: path/to/my/amount
    //
    // thus, the produced code will be something like :
    //
    //      sprintf("%01.2f", $ctx->get("path/to/my/amount"))
    //
    // This code will be included right into the template where needed.
    //
    // @param string $src
    //      The expression string
    // @param string $nothrow
    //      A boolean indicating if exceptions may be throw by phptal_path if
    //      the path does not exists.
    // @return string
    //      PHP code to include in the template
    //
    function phptal_tales_money( $src, $nothrow )
    {
        // remove spaces we do not require here
        $src = trim($src); 
        return 'sprintf("%01.2f", '.phptal_tales_path($src, $nothrow).')';
    }

USEFULL LINKS
*************

  - Zope Page Template front page :     
    http://www.zope.org/Wikis/Projects/ZPT
  - TAL : Template Attribute Language page 
    http://www.zope.org/Wikis/DevSite/Projects/ZPT/TAL
  - METAL : Macro Expansion of TAL 
    http://www.zope.org/Wikis/DevSite/Projects/ZPT/METAL
  - TALES : TAL Expression Syntax
    http://www.zope.org/Wikis/DevSite/Projects/ZPT/TALES

GREETINGS
*********

  Big thanks goes to :

  - ZPT team, who made these usefull specifications,
  - The PHPTAL community for their support, help and reports,
  - Jean-Michel Hiver, who 'forced' me to look at them,
  - Olivier Parisy, the first entousiast PHPTAL user and bug reporter.


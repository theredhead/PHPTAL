<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<book lang="en">

  <bookinfo>
    <title>PHPTAL Manual</title>
    <subtitle>PHP Template Attribute Language</subtitle>
    <date>2008-10-03</date>
    <author>
      <firstname>Laurent</firstname><surname>Bédubourg</surname>
      <address><email>lbedubourg@motion-twin.com</email></address>
    </author>
    <author>
       <firstname>Kornel</firstname><surname>Lesiński</surname>
       <address><email>kornel@aardvarkmedia.co.uk</email></address>
    </author>
	<author>
		<firstname>Dan</firstname><surname>Sheppard</surname>
	</author>
	<author>
		<firstname>Anton</firstname><surname>Andriyevskyy</surname>
			<othername>Valeriyevich</othername>
      <address><email>x.meglio@gmail.com</email></address>
	</author>	

    <revhistory id="revhistory">
        <revision>
			  <revnumber>v1.6</revnumber>
				<date>2008-10-03</date>
				<authorinitials>kl</authorinitials>
				<revremark>Fixed errors spotted by Anton.</revremark>
		</revision>
        <revision>
			  <revnumber>v1.5</revnumber>
				<date>2008-08-21</date>
				<authorinitials>kl</authorinitials>
				<revremark>Removed old defines, documented configuration methods.</revremark>
		  </revision>
        <revision>
			  <revnumber>v1.4</revnumber>
				<date>2008-08-18</date>
				<authorinitials>kl</authorinitials>
				<revremark>Corrections and updates for PHPTAL 1.1.13</revremark>
		  </revision>
		  <revision>
			  <revnumber>v1.3</revnumber>
				<date>2008-01-27</date>
				<authorinitials>kl</authorinitials>
				<revremark>Updated for PHPTAL 1.1.10</revremark>
		  </revision>
		  <revision>
			  <revnumber>v1.2</revnumber>
				<date>2005-12-10</date>
				<authorinitials>ds</authorinitials>
				<revremark>English Corrections by Dan Sheppard</revremark>
		  </revision>
      <revision>
        <revnumber>v1.1</revnumber>
        <date>2005-03-29</date>
        <authorinitials>lb</authorinitials>
        <revremark>Added section about PHPTAL class</revremark>
      </revision>
      <revision>
        <revnumber>v1.0</revnumber>
        <date>2005-03-27</date>
        <authorinitials>lb</authorinitials>
        <revremark>Converted draft to docbook</revremark>
      </revision>
    </revhistory>

    <!--
    <abstract>
      <para>
      Bla bla bla PHPTAL
      </para>
    </abstract>
    -->
  </bookinfo>

  <article id="introduction">
    <title>Introduction</title>
  
    <para>
    <acronym>PHPTAL</acronym> is an implementation of the excellent Zope Page Template 
    (<acronym>ZPT</acronym>) system for <acronym>PHP</acronym>. <acronym>PHPTAL</acronym> supports <acronym>TAL</acronym>, <acronym>METAL</acronym>, <acronym>I18N</acronym> namespaces.
    </para>
  
    <para>
    <acronym>PHPTALES</acronym> is the equivalent of <acronym>TALES</acronym>, the Template Attribute Language 
    Expression Syntax. It defines how <acronym>XML</acronym> attribute values are handled.
    </para>

    <para>
    As <acronym>PHPTALES</acronym> is similar to <acronym>TALES</acronym>, it should be easy to port python <acronym>TAL</acronym> 
    templates into <acronym>PHP</acronym> ones (and vice versa).
    </para>

    <para>
    To be <acronym>TAL</acronym> compliant, <acronym>PHPTAL</acronym> implements XPath-like access to data.
    </para>

    <para>
    <acronym>PHPTAL</acronym> is freely distributed under the <acronym>LGPL</acronym> license, it is 
    developed by Laurent Bedubourg 
    <email>lbedubourg@motion-twin.com</email> and maintained by Kornel Lesiński.
    </para>
    
  </article>

  <article id="whyusephptal">
    <title>Why use <acronym>PHPTAL</acronym></title>

    <para>
    <acronym>XML</acronym>/<acronym>HTML</acronym> templates exist to separate logic from presentation in web 
    services. This separation brings more than one accompanying benefit.
    </para>

    <itemizedlist>
      <listitem><para>better application design</para></listitem>
      <listitem><para>easier task repartition</para></listitem>
      <listitem><para>better maintainability</para></listitem>
      <listitem><para>easy web skins</para></listitem>
    </itemizedlist>

    <para>
    Most template systems uses <sgmltag>&lt;? ?&gt;</sgmltag>, <sgmltag>&lt;% %&gt;</sgmltag> or
    <sgmltag>&lt;xxx:yyy&gt;&lt;/xxx:yyy&gt;</sgmltag> tags to find their sections. It
    allows easier template system development but doesn't really help
    template designers.
    </para>

    <para>
    <acronym>TAL</acronym> hides most of its logic in <acronym>XML</acronym> attributes, preserving syntax and strucutre of <acronym>XHTML</acronym>. This allows previewing of <acronym>TAL</acronym> templates in web browser (<acronym>WYSIWYG</acronym> editors, live previews) and doesn't break <acronym>HTML</acronym> syntax highlighting in programmers' editors.
    </para>

    <para>
    If you have already worked with a simple template system, then you must 
    have encountered something looking like:
    </para>
  
    <programlisting language="xml"><![CDATA[<table>
  <%loop myarray as myitem %>
  <tr>
    <td><% myitem %></td>
  </tr>
  <%/loop%>
</table>
]]></programlisting>

    <para>
    Well, with <acronym>PHPTAL</acronym> you now can write:
    </para>

    <programlisting language="xml"><![CDATA[<table>
  <tr tal:repeat="myitem myarray">
    <td tal:content="myitem">
      text replaced by the item value
    </td>
    <td tal:replace="">sample 1</td>
    <td tal:replace="">sample 2</td>
    <td tal:replace="">sample 3</td>
  </tr>
</table>
]]></programlisting>

    <para>
    The above code will render correctly with the sample
    text in normal web browser, so you can present it to your clients even if the code 
    required to get 'myarray' values doesn't yet exist.
    </para>

    <para>
    Another big advantage of <acronym>PHPTAL</acronym> is that you benefit from more than 3 
    years of Zope community experience, documentation, examples, and help.  
    <acronym>PHPTAL</acronym> relies on this community to provide its users a great deal
    of useful information.
    </para>

    <para>
    <acronym>PHPTAL</acronym> is designed to be as customizable as possible for advanced 
    developers and performance-eating systems, but still be easy to use for 
    beginners, with a comfortable and simple default behaviour (at least I 
    tried :)
    </para>

  </article>

  <article id="installation">
    <title>Installation</title>

    <para>
    <acronym>PHPTAL</acronym> is released as a <acronym>PEAR</acronym> package (see <ulink 
    url="http://pear.php.net">http://pear.php.net</ulink>).  You can 
    download the <acronym>PHPTAL</acronym> library on the <acronym>PHPTAL</acronym> website (<ulink 
    url="http://phptal.motion-twin.com">http://phptal.motion-twin.com</ulink>).
    </para>

    <para>
    You can install it using the pear utility:
    </para>

    <programlisting><![CDATA[pear install http://phptal.motion-twin.com/latest.tar.gz
]]></programlisting>
  
  
    <para>
    Once installed, you can upgrade <acronym>PHPTAL</acronym> easily on each <acronym>PHPTAL</acronym> update 
    using <acronym>PEAR</acronym>:
    </para>

    <programlisting><![CDATA[pear upgrade http://phptal.motion-twin.com/latest.tar.gz
]]></programlisting>  

    <para>
    If you do not use <acronym>PEAR</acronym> or do not have it installed on your system, 
    you can still install <acronym>PHPTAL</acronym> by unzipping the downloaded archive.  
    </para>

    <programlisting><![CDATA[tar zxvf PHPTAL-X.X.X.tar.gz
cp -r PHPTAL-X.X.X/PHPTAL* /path/to/your/lib/folder
]]></programlisting>

    <para>
    This will install the <filename>PHPTAL.php</filename> file and the associated <acronym>PHPTAL</acronym> 
    folder in /path/to/your/lib/folder.
    </para>
    
  </article>

  <article id="firstexample">
    <title>First example</title>

    <para>
    To get a first impression of <acronym>PHPTAL</acronym> usage, a simple example is 
    better than many words.
    </para>

    <para>
    Your template is a valid xml/html document (with a root element).  
    Here's a file named 'my_template_file.xhtml'.
    </para>
  
    <programlisting language="xml"><![CDATA[<?xml version="1.0"?>
<html>
  <head>
    <title tal:content="title">
      Place for the page title
    </title>
  </head>
  <body>
    <h1 tal:content="title">sample title</h1>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Phone</th>
        </tr>
      </thead>
      <tbody>
        <tr tal:repeat="person people">
          <td tal:content="person/name">person's name</td>
          <td tal:content="person/phone">person's phone</td>
        </tr>
        <tr tal:replace="">
          <td>sample name</td>
          <td>sample phone</td>
        </tr>
        <tr tal:replace="">
          <td>sample name</td>
          <td>sample phone</td>
        </tr>
      </tbody>
    </table>
  </body>
</html>
]]></programlisting>

    <para>
    In php, you just have to include the <acronym>PHPTAL</acronym> library, and maybe   
    configure a few variables to customize the template system.
    </para>

    <programlisting><![CDATA[<?php
require_once 'PHPTAL.php';

// create a new template object 
$template = new PHPTAL('my_template_file.xhtml');

// the Person class 
class Person {
    public $name;
    public $phone;
    
    function Person($name, $phone) {
        $this->name = $name;
        $this->phone = $phone;
    }
}

// let's create an array of objects for test purpose
$people = array();
$people[] = new Person("foo", "01-344-121-021");
$people[] = new Person("bar", "05-999-165-541");
$people[] = new Person("baz", "01-389-321-024");
$people[] = new Person("quz", "05-321-378-654");

// put some data into the template context
$template->title = 'The title value';
$template->people = $people;

// execute the template 
try {
    echo $template->execute();
}
catch (Exception $e){
    echo $e;
}
?>
]]></programlisting>
    
    <para>
    If you execute the <acronym>PHP</acronym> script, you will obtain something similar to 
    what follows.
    </para>

    <programlisting language="xml"><![CDATA[<?xml version="1.0"?>
<html>
  <head>
    <title>The title value</title>
  </head>
  <body>
    <h1>The title value</h1>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Phone</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>foo</td>
          <td>01-344-121-021</td>
        </tr><tr> <td>bar</td>
          <td>05-999-165-541</td>
        </tr><tr> <td>baz</td>
          <td>01-389-321-024</td>
        </tr><tr> <td>quz</td>
          <td>05-321-378-654</td>
        </tr>
      </tbody>
    </table>
  </body>
</html>
]]></programlisting>

    <para>

    <acronym>PHPTAL</acronym> doesn't care much about line breaks and indentation in files it reads and generates. If you want source code of generated HTML files to be pretty (with line breaks and perfect indentation), then you might need to postprocess it with HTML Tidy.
    </para>

  </article>

  <article id="attributelanguage">
    <title>Template Attribute Language</title>

    <para>
    This section describes <acronym>TAL</acronym> and its extensions. It mainly targets 
    template designers but must be read by <acronym>PHP</acronym> integrators as well.
    </para>

    <section id="attributes">
      <title>Attribute priority</title>

      <para>
      It is important to note that the order of declaration of 
      attributes is irrelevant.
      </para>

      <para>
      For example,
      </para>

      <programlisting language="xml"><![CDATA[<span tal:define="usersList application/listUsers" 
      tal:condition="somecondition"
      tal:repeat="user usersList"
>…</span>
]]></programlisting>

      <para>
      Is <emphasis>exactly</emphasis> the same as:
      </para>

      <programlisting language="xml"><![CDATA[<span tal:repeat="user usersList"
      tal:condition="somecondition"
      tal:define="usersList application/listUsers" 
>…</span>
]]></programlisting>

      <para>
      Priority is the same as described by <acronym>TAL</acronym> specifications:
      </para>

      <orderedlist>
        <listitem><para>define</para></listitem>
        <listitem><para>condition</para></listitem>
        <listitem><para>repeat</para></listitem>
        <listitem><para>content or replace</para></listitem>
        <listitem><para>attributes</para></listitem>
        <listitem><para>omit-tag</para></listitem>
      </orderedlist>

<!-- Hard to understand here, just skip this for now
      <para>
      Because <acronym>PHPTAL</acronym> implements METAL and I18N, this list is completed 
      as follow:
      </para>

    1.  phptal:debug
    2.  phptal:tales
    3.  phptal:omit-tag (not exactly the same position but same effect)
    4.  metal:define-macro
    5.  tal:on-error
    6.  i18n:domain
    7.  tal:define
    8.  i18n:name
    9.  i18n:translate
    10. tal:condition
    11. phptal:id
    12. tal:repeat
    13. tal:attributes
    14. tal:replace
    15. metal:use-macro
    16. metal:define-slot
    17. metal:fill-slot
    18. i18n:attributes
    19. tal:content
    20. tal:comment
-->

    </section>

    <section id="tal-namespace">
      <title><acronym>TAL</acronym> namespace</title>

      <para></para>

      <section id="tal-define">
        <title><sgmltag>tal:define</sgmltag></title>

        <para>
        This attribute defines one or more variables which may be used 
        later in the template.
        </para>

        <para>
        Making a shortcut to a long path:
        </para>

        <programlisting language="xml"><![CDATA[<span tal:define="global destname path/to/existing/variable" />
]]></programlisting>

        <para>
        Creating a string inside the template:
        </para>

        <programlisting language="xml"><![CDATA[<span tal:define="global destname string:some string" />
]]></programlisting>

        <para>
        Defining more than one variable at the same time:
        </para>

        <programlisting language="xml"><![CDATA[<span tal:define="global fname string:paul; lname string:dupond" />
]]></programlisting>

        <para>
        Defining a string containing another variable:
        </para>
  
        <programlisting language="xml"><![CDATA[<span tal:define="global hello string:hello $fname welcome on this page" />
]]></programlisting>

        <para>
        A small trick which uses output buffers:
        </para>

        <programlisting language="xml"><![CDATA[<span tal:define="global hello">hello ${fname} welcome on this page</span>
]]></programlisting>

        <para>
        You may also use <sgmltag>tal:define</sgmltag> with other attributes, it will be 
        executed before any other attributes.
        </para>

        <para>
        In above examples, the span tag won't show up because it has no
        printable content nor attributes. Even the last example does not 
        show the message because the 'hello' variable grabs it.
        </para>

        <para>
        On the other hand:
        </para>

        <programlisting language="xml"><![CDATA[<span tal:define="hello string:hello ${fname} welcome on this page"
      tal:content="hello"
/>
]]></programlisting>

        <para>
        Will both set the hello variable and print it.
        </para>

        <para>
	<emphasis>but</emphasis> the following is irregular because <sgmltag>tal:define</sgmltag> will
	calculate the content of the node before being executed and
	<sgmltag>tal:content</sgmltag> IS the content of the node. Whatever is inside the
	span is just ignored. Thus hello won't be defined and an
	exception will be thrown.
        </para>

        <programlisting language="xml"><![CDATA[<span tal:define="hello" tal:content="hello">
  hello ${fname} welcome on this page
</span>
]]></programlisting>

	<para>
	In above examples, you may have spotten the 'global' keywords before some variables names. In <acronym>PHPTAL</acronym> you can either define a variable globally or locally.</para>
	
	<para>
	A global variable will be accessible from any <acronym>XML</acronym> node of your templates or called macros.
	</para>

	<programlisting language="xml"><![CDATA[<span tal:define="global hello string:hello world"/>
<p tal:content="hello"/>
]]></programlisting>

	<para>
	On the contrary, a local variable is only available inside the tag it is defined in:
	</para>

	<programlisting language="xml"><![CDATA[<span tal:define="hello string:hello world"/>
<p tal:content="hello"/> <!-- will produce an undefined variable error -->
]]></programlisting>

      </section>


      <section id="tal-condition">
        <title><sgmltag>tal:condition</sgmltag></title>

        <para>
        The entity and its content will be shown only if the condition 
        is evaluated to true.
        </para>
  
        <programlisting language="xml"><![CDATA[<span tal:condition="identified"> Welcome member …  </span>
]]></programlisting>

        <programlisting language="xml"><![CDATA[<span tal:condition="not: identified">
  Please login before accessing this page
</span>
]]></programlisting>

        <para>
        If the <acronym>PHP</acronym> backend does not provide your templates with enough 
        methods, you will often have to fall back to <acronym>PHP</acronym> for special 
        conditions:
        </para>

        <programlisting language="xml"><![CDATA[<span tal:comment="show only if more than five items in the cart"
      tal:condition="php: cart.countItems() GT 5">…</span>
]]></programlisting>

        <para>
        This may put too much logic inside the template and it is 
        sometimes preferable to provide boolean attributes or accessible 
        methods to the template:
        </para>

        <programlisting language="xml"><![CDATA[<span tal:condition="cart/hasMoreThanFiveItems">…</span>
]]></programlisting>

        <programlisting language="xml"><![CDATA[<span tal:condition="fullfillNumerousItems">…</span>
]]></programlisting>

      </section>

      <section id="tal-repeat"> 
        <title><sgmltag>tal:repeat</sgmltag></title>

        <para>
        This attribute handles iterable objects like arrays, associative 
        arrays, and objects implementing the PHP5 Iterable class.
        </para>

        <para>
        The repeat attribute repeats its element and its content until 
        the end of the specified resource.
        </para>

        <programlisting language="xml"><![CDATA[<tr tal:repeat="item some/result">
  <td tal:content="item">text replaced by item</td>
</tr>
]]></programlisting>

        <para>
        Within a loop, you can access the current loop information
        (and that of its parent for nested loops) using specific
        <varname>repeat/<replaceable>*</replaceable></varname> paths.
        </para>

        <para>
        In the above example:
        </para>

        <itemizedlist>
          <listitem><para>
            <varname>repeat/item/key</varname>    : returns the item's key if some/result is 
            an associative resource (index otherwise)
          </para></listitem>
          <listitem><para>
          <varname>repeat/item/index</varname>  : returns the item index (0 to count-1)
          </para></listitem>
          <listitem><para>
          <varname>repeat/item/number</varname> : returns the item number (1 to count)
          </para></listitem>
          <listitem><para>
          <varname>repeat/item/even</varname>   : returns true if item index is even
          </para></listitem>
          <listitem><para>
          <varname>repeat/item/odd</varname>    : returns true if item index is odd
          </para></listitem>
          <listitem><para>
          <varname>repeat/item/start</varname>  : returns true if item is the first one 
          </para></listitem>
          <listitem><para>
          <varname>repeat/item/end</varname>    : returns true if item is the last one 
          </para></listitem>
          <listitem><para>
          <varname>repeat/item/length</varname> : returns the number of elements in 
          some/result
          </para></listitem>
        </itemizedlist>

        <para>
        "item" depends on the receiver variable defined in <sgmltag>tal:repeat</sgmltag> 
        expression.
        </para>

        <para>
        The most common usage of <sgmltag>tal:repeat</sgmltag> is in using some <acronym>SQL</acronym>
        database result.  The following code will work if <varname>playersRanking</varname> contains object that implements <acronym>PHP</acronym>'s <constant>Iterator</constant> interface:
        </para>

        <programlisting language="xml"><![CDATA[<table>
  <thead>
    <tr>
      <th>Position</th>
      <th>Player</th>
      <th>Score</th>
    </tr>
  </thead>
  <tbody>
    <tr tal:repeat="ranking playersRanking">
      <td tal:content="ranking/position"/>
      <td tal:content="ranking/player"/>
      <td tal:content="ranking/score"/>
    </tr>
  </tbody>
</table>
]]></programlisting>

      </section>

      <section id="tal-omit-tag">
        <title><sgmltag>tal:omit-tag</sgmltag></title>

        <para>
        This attribute asks the <acronym>PHPTAL</acronym> parser to ignore the entity's open and 
        close tag, its content will still be evaluated.
        </para>

        <programlisting language="xml"><![CDATA[<span tal:omit-tag="condition">
  if the condition is true, then only this text will appear and span open and close will be removed
</span>
]]></programlisting>

        <para>
        Will produce:
        </para>

        <programlisting><![CDATA[only this text will appear, span open and close will be removed
]]></programlisting>

        <para>
        This attribute is useful when you want to create element optionally, e.g. hide a link if certain condition is met.
        </para>
        
        <para>If you want element that is never output, you can use <sgmltag>tal:block</sgmltag></para>
        <programlisting language="xml"><![CDATA[<tal:block tal:repeat="x php:range(1,10)">only this text will appear, ten times.</tal:block>
]]></programlisting>

      </section>

      <section id="tal-replace">
        <title><sgmltag>tal:replace</sgmltag></title>

        <para>
        This attribute will replace the entire tag with a value, or by 
        nothing if no value is given.
        </para>

        <programlisting language="xml"><![CDATA[<span tal:replace="string:this beautiful string">
  this ugly string and span
</span>
]]></programlisting>

        <para>
        Will produce:
        </para>

        <programlisting><![CDATA[this beautiful string
]]></programlisting>

        <para>
        <sgmltag>tal:replace</sgmltag> can also be used to create samples in source 
        templates, but remove them from final output.
        </para>

        <programlisting language="xml"><![CDATA[<table>
  <tr tal:repeat="item myresult">
    <td tal:content="item">item value</td>
  </tr>
  <tr tal:replace="">
    <td>sample 1</td>
  </tr>
  <tr tal:replace="">
    <td>sample 2</td>
  </tr>
</table>
]]></programlisting>

      </section>

      <section id="tal-content">
        <title><sgmltag>tal:content</sgmltag></title>

        <para>
        This attribute replaces the tag content with the evaluation of 
        its expression.
        </para>

        <programlisting language="xml"><![CDATA[<span tal:define="myvar string:my string"/>
<span tal:content="myvar">will be replaced</span>
]]></programlisting>

        <para>
        Will produce:
        </para>

        <programlisting language="xml"><![CDATA[<span>my string</span>
]]></programlisting>

      </section>

      <section id="tal-attributes">
        <title><sgmltag>tal:attributes</sgmltag></title>

        <para>
        This attribute changes tag attribute(s) value(s).
        </para>

        <programlisting language="xml"><![CDATA[<a href="http://www.foo.com" title="some foo link"
   tal:attributes="href somelink/href; title somelink/title" 
  tal:content="somelink/text"
>sample link</a>
]]></programlisting>

        <para>
        With a '<varname>somelink</varname>' having:
        </para>

        <programlisting><![CDATA[$somelink->href = "http://www.google.com";
$somelink->title = "google search engine";
$somelink->text = "the google search engine";
]]></programlisting>

        <para>
        Will produce:
        </para>

        <programlisting language="xml"><![CDATA[<a href="http://www.google.com" 
title="google search engine">the google search engine</a>
]]></programlisting>

        <para>Semicolon (<literal>;</literal>) separates attributes. If you want semicolon to be output in an attribute, you have to double it (<literal>;;</literal>).</para>

        <para>
        A somewhat complicated example involving <sgmltag>tal:repeat</sgmltag>:
        </para>

        <programlisting language="xml"><![CDATA[<tr tal:repeat="ranking playerRankings"
    tal:attributes="class php: repeat.ranking.odd ? 'odd' : NULL">
    …
</tr>
]]></programlisting>

        <para>
        The php: modifier will be explained later, basically if the line 
        is odd then <sgmltag>tr</sgmltag> will have a <sgmltag>class</sgmltag> attribute with "odd" as value, 
        otherwise, no class will be set.
        </para>

        <para>
        The "<code>condition ? then : else</code>" is a regular <acronym>PHP</acronym> expression which 
        must be used with care but has proven to be useful on more 
        than one occasion.
        </para>

        <para>
        A better way to achieve the same result would be to ask your <acronym>PHP</acronym> 
        coder to create a custom modifier for your needs (see <acronym>PHP</acronym> 
        integration / custom modifiers) which would be used as follows:
        </para>
                
        <programlisting language="xml"><![CDATA[<tr tal:repeat="ranking playerRankings"
    tal:attributes="class css-odd:repeat/ranking/odd">
  …
</tr>
]]></programlisting>

        <para>
        The modifier would return "odd" if <varname>repeat/ranking/odd</varname> is true, 
        false otherwise.
        </para>
<section id="optional-attrs"><title>Optional attributes</title>
        <para>If you use <acronym>TALES</acronym> alternatives in <sgmltag>tal:attributes</sgmltag> and use <varname>nothing</varname> (or <varname>NULL</varname> in php) as last alternative,
            attribute won't be added at all if there's no value for it (this avoids adding empty attributes):</para>
        <programlisting language="xml"><![CDATA[… tal:attributes="title object/tooltip | nothing"> ]]></programlisting>

        <para><acronym>XHTML</acronym> attributes like <sgmltag>selected</sgmltag>, <sgmltag>checked</sgmltag>, etc. are properly handled automatically.</para>

        <programlisting language="xml"><![CDATA[<input type="checkbox" tal:attributes="checked object/isChecked"/>]]></programlisting>
        
        <para>
            Remember that <acronym>XHTML</acronym> is case-sensitive, so <sgmltag>SELECTED</sgmltag> attribute is an error in <acronym>XHTML</acronym>. Use <sgmltag>selected</sgmltag>.
        </para>
      </section>
    </section>
      <section id="tal-on-error">
        <title><sgmltag>tal:on-error</sgmltag></title>

        <para>
        This attribute replaces the tag by the <sgmltag>tal:on-error</sgmltag> expression 
        evaluation if a path error is detected in the tag content, or if 
        any <acronym>PHP</acronym> exception is thrown in the tag content.
        </para>

        <programlisting language="xml"><![CDATA[<span tal:on-error="string:No username defined here"
      tal:content="user/name">the user name here</span>
]]></programlisting>

        <para>
        If an error occurs accessing 'name' or 'user', the error string 
        will be shown at the tag's place.
        </para>

        <para>
        This also works on more than one level of template:
        </para>

        <programlisting language="xml"><![CDATA[<span tal:on-error="string:error occurred somewhere">
  <span tal:content="user/firstname"/>
  <span tal:content="user/lastname"/>
  <span metal:use-macro="userMenu" />
</span>
]]></programlisting>
    
      </section>
    
    </section><!-- end of TAL namespace -->

    <section id="metal">
      <title><acronym>METAL</acronym> namespace</title>

      <para>
      <acronym>METAL</acronym> stands for 'Macro Extension for <acronym>TAL</acronym>'. This namespace, 
      supported by <acronym>PHPTAL</acronym>, allows template designers to define and call 
      <acronym>XML</acronym>/<acronym>XHTML</acronym> macros.
      </para>

      <section id="metal-define-macro">
        <title><sgmltag>metal:define-macro</sgmltag></title>

        <para>
        This attribute declares a macro. Think of macros as library of 
        small templates which can be reused in any other template.
        </para>

        <programlisting language="xml"><![CDATA[<div metal:define-macro="main_menu">
  <ul>
    <li><a href="/">home</a></li>
    <li><a href="/products">products</a></li>
    <li><a href="/contact">contact</a></li>
  </ul>

  <div>
    Last modified:
    <span tal:content="mdate">page modification date</span>
  </div>
</div>
]]></programlisting>

        <para>
        Macros inherit from the caller's dictionary. In the above example, 
        the variable 'mdate' depends on the template that calls the 
        macro.
        </para>
      </section>

      <section id="metal-use-macro">
        <title><sgmltag>metal:use-macro</sgmltag></title>

        <para>
        This attribute calls a macro and includes its result in the 
        current template.
        </para>

        <programlisting language="xml"><![CDATA[<span
  tal:comment="main_menu template requires 'mdate' variable"
  tal:define="mdate page/last_modified"
  metal:use-macro="main_menu"
/>
]]></programlisting>
        
        <para>
        You can refer to external macros defined in other templates by 
        specifying the template source file.
        </para>

        <programlisting language="xml"><![CDATA[<span metal:use-macro="site_macros.xhtml/main_menu"/>
]]></programlisting>

        <para>
        It is interesting to note that you can also use the <acronym>PHPTAL</acronym> inline 
        replacement feature inside the use-macro attribute value:
        </para>

        <programlisting language="xml"><![CDATA[<span metal:use-macro="${design}/site_macros.xhtml/main_menu"/>
]]></programlisting>


        <para>Macro can call itself. This way you can output arrays recursively:</para>
        <programlisting language="xml"><![CDATA[        <ul metal:define-macro="show-list">
            <li tal:repeat="item list">
                <tal:block tal:condition="php:is_array(item)" tal:define="list item" metal:use-macro="show-list" />
                <tal:block tal:condition="php:!is_array(item)" tal:content="item" />
            </li>
        </ul>        
        ]]></programlisting>

      </section>


      <section id="metal-define-slot">
        <title><sgmltag>metal:define-slot</sgmltag></title>

        <para>
        This attribute must appear inside a <sgmltag>metal:define-macro</sgmltag> tag.
        </para>

        <para>
        Slots can be replaced by caller template with some custom 
        dynamically-generated <acronym>XML</acronym>/<acronym>XHTML</acronym>.
        </para>

        <para>
        Slots can be thought of like reverse includes, a macro can be an 
        entire page and slots customize this page depending on the <acronym>URL</acronym>.  
        For instance, a slot may contain the latest news in the home page 
        or user actions when the member is logged in.
        </para>

        <programlisting language="xml"><![CDATA[<span metal:define-slot="news_place">
  <table>
    <tr tal:repeat="item php:latestNews()">
      <td tal:content="item/value">news description</td>
    </tr>
  </table>
</span>
]]></programlisting>

        <para>
        The above example defines a place called 
        '<emphasis>news_place</emphasis>' which can be overwritten by 
        caller templates. See next section for the continuation of this 
        example.
        </para>

      </section>


      <section id="metal-fill-slot">
        <title><sgmltag>metal:fill-slot</sgmltag></title>

        <para>
        This attribute can occur only inside <sgmltag>metal:use-macro</sgmltag> element.
        </para>

        <para>
        This explicitly tells <acronym>PHPTAL</acronym> to replace a defined slot with the 
        content provided inside the <sgmltag>metal:fill-slot</sgmltag> attribute.
        </para>

        <programlisting language="xml"><![CDATA[<span tal:condition="logged" metal:fill-slot="news_place">
  <h2>user menu</h2>
  <ul>
    <li><a href="/user/action/inbox">inbox</a></li>
    <li><a href="/user/action/new">new mail</a></li>
    <li><a href="/user/action/disconnect">disconnect</a></li>
  </ul>
</span>
]]></programlisting>

        <para>
        Slots give the opportunity to define really customizable and 
        reusable page templates with a simple push technology.
        </para>
      </section>
  
    </section><!-- end of METAL namespace -->
    

    <section id="i18n">
      <title><acronym>I18N</acronym> namespace</title>

      <para>
      Note: 'i18n' is a short name for 'internationalization'. This 
      namespace allow template designers to specify some text zones that 
      must be translated during template evaluation.
      </para>

      <section id="i18n-translate">
        <title><sgmltag>i18n:translate</sgmltag></title>

        <para>
        This attribute defines some text part that must be translated 
        using <acronym>PHPTAL</acronym>'s translation system.
        </para>

        <programlisting language="xml"><![CDATA[<div i18n:translate="string:welcome_message">Welcome here</div>
]]></programlisting>

        <para>
        In the above example, <acronym>PHPTAL</acronym> will looks for a translation key 
        named 'welcome_message' and will replace the content of the tag 
        with the equivalent in currently requested language.
        </para>

        <programlisting language="xml"><![CDATA[<div i18n:translate="">Welcome here</div>
]]></programlisting>

        <para>
        This usage is a little different, no translation key is given,
        thus <acronym>PHPTAL</acronym> will use the content of the tag 'Welcome here' as
        the translation key.  This is a regular translation if
        translation system knows the key 'Welcome here'.
        </para>

        <para>
        If no translation is found, the key will be used as the 
        translation result. That's why using readable message instead 
        of keys may be a good choice.
        </para>

        <para>
        Please note that the key to translate may be contained in a 
        variable, to allow dynamic key selection.
        </para>

        <programlisting language="xml"><![CDATA[<div tal:define="welcome random_welcome_message">
  <div i18n:translate="welcome">…</div>
</div>]]></programlisting>

      </section>
      
      <section id="i18n-attributes">
          <title><sgmltag>i18n:attributes</sgmltag></title>

          <para>
              Defines which attributes should be translated. Takes semicolon-separated list of attributes and keys similar to those for <sgmltag>i18n:translate</sgmltag>.
          </para>      
          <programlisting language="xml"><![CDATA[<img i18n:attributes="alt 'picture alternative text';title thetitle" alt="Picture" title="${thetitle}" />
]]></programlisting>
  
      </section>      

      <section id="i18n-name">
        <title><sgmltag>i18n:name</sgmltag></title>

        <para>
        This attribute sets a translation variable value.
        </para>

        <para>
        Translations may contain <varname>${xxx}</varname> strings where "<varname>xxx</varname>" is the  
        name of a variable that needs to be interpolated dynamically.
        </para>

        <para>
        The value of this variable will be set to the tag and its 
        content. If you don't need tag around the value, use 
        <sgmltag>tal:replace</sgmltag> instead of <sgmltag>tal:content</sgmltag>. <sgmltag>tal:omit-tag</sgmltag> may help if the 
        value is a concatenation of strings.
        </para>

        <programlisting language="xml"><![CDATA[<span i18n:name="myVar" tal:content="some/path"/>
<!-- <span>${some/path}</span> -->

<span i18n:name="myVar" tal:replace="some/path"/>
<!-- ${some/path} -->

<span i18n:name="myVar">foo</span>
<!-- <span>foo</span> -->

<span i18n:name="myVar" tal:omit-tag="">foo</span>
<!-- foo -->
]]></programlisting>

        <para>
        An example of i18n usage:
        </para>

        <programlisting language="xml"><![CDATA[<div i18n:translate="">
  Welcome <span i18n:name="user" tal:replace="user/name"/>,
  you have <span i18n:name="mails" tal:replace="user/nbrMails"/>
  unread mails.
</div>
]]></programlisting>

        <para>
        The translation key of this example will be:
        </para>

        <programlisting><![CDATA["Welcome ${user}, you have ${mails} unread mails."
]]></programlisting>

        <para>
        <acronym>PHPTAL</acronym> will replace <varname>${user}</varname> with <varname>${user/name}</varname> and <varname>${mails}</varname> with 
        <varname>${user/nbrMails}</varname> in translation.
        </para>

        <para>
        More information about <acronym>I18N</acronym> with <acronym>PHPTAL</acronym> is available in the <acronym>PHP</acronym> 
        section of this book.
        </para>
      </section>
      
      <section id="xhtml-in-translations"><title><acronym>XHTML</acronym> in translations</title>
          <para>By defaults translations are assumed to contain only text, so <acronym>PHPTAL</acronym> escapes all "&lt;" characters.</para>
          <para>As of 1.1.14 you can use structure keyword in <sgmltag>i18n:translate</sgmltag> to disable escaping and use translated text as-is:</para>
          
           <programlisting language="xml"><![CDATA[      <div i18n:translate="structure '<b>bold text</b>'" />
      ]]></programlisting>
      <para>Gives:</para>
          
             <programlisting language="xml"><![CDATA[        <div><b>bold text</b></div>
        ]]></programlisting>
      
      <para>Caveats: This will only work in simplest cases – <acronym>TAL</acronym> attributes inside translated strings are ignored. Ill-formed <acronym>XHTML</acronym> in translations will break page well-formedness.</para>      
    </section>

    </section><!-- end of I18N namespace -->
   

    <section id="phptal-namespace">
      <title><acronym>PHPTAL</acronym> namespace</title>

      <para>
      These attributes are not defined in <acronym>TAL</acronym> specifications, but are 
      useful when working with <acronym>PHPTAL</acronym>.
      </para>

      <section id="phptal-debug">
        <title><sgmltag>phptal:debug</sgmltag></title>

        <para>
        This attribute toggles the activation of <acronym>PHPTAL</acronym> debugging for
        the content of the tag it is defined in.
        </para>

        <note><para>To debug errors in macros called across templates you need to add <sgmltag>phptal:debug</sgmltag> in template which <emphasis>defines</emphasis> the macro, not the one which uses it.</para></note>

        <para>
        The debug mode stores information like filename and source line 
        number in the template, so exceptions thrown by incorrect path 
        access will contain more information about where they where 
        thrown.
        </para>
        
        <programlisting language="xml"><![CDATA[<html>
  <head>
    …
  </head>
  <body>
    <div id="menu">
      …
    </div>
    <div id="leftPane" phptal:debug=""
      tal:comment="this div seems buggy, keep
      trace of where errors are thrown">
          …
    </div>
  </body>
</html>
]]></programlisting>

      </section>


           <section id="phptal-cache">
              <title><sgmltag>phptal:cache</sgmltag></title>

              <para>
              This attribute causes output of entire element (including its tag) to be cached on disk and not re-evaluated until cache expires.
              </para>

              <note><para>Use of cache is beneficial only for elements that use very complex expressions, macros from external files or <acronym>PHP</acronym> expressions/objects that access the database. Otherwise uncached templates will be just as fast.</para></note>
              
                <para>Content of this attribute is a duration (how long element should be kept in cache) written as number with '<constant>d</constant>', '<constant>h</constant>', '<constant>m</constant>' or '<constant>s</constant>' suffix.
            </para>
            <programlisting language="xml"><![CDATA[<div class="footer" phptal:cache="3h">…</div>]]></programlisting> 
            <para>                  <sgmltag>&lt;div></sgmltag> will be evaluated at most once per 3 hours.</para>
            
            <para>Duration can be followed by optional "<varname>per</varname>" parameter that defines how cache should be shared. By default cache is shared between all pages that use that template. 
                  You can add "<varname>per url</varname>" to have separate copy of given element for every <acronym>URL</acronym>.
</para>

            <programlisting language="xml"><![CDATA[<ol id="breadcrumbs" phptal:cache="1d per url">…</ol>]]></programlisting>
          <para><sgmltag>&lt;ol></sgmltag> will be cached for one day, separately for each page.</para>
<para>
                  You can add "<varname>per expression</varname>" to have different cache copy for every different value of an expression (which MUST evaluate to a string). 
                  Expression cannot refer to variables defined using <sgmltag>tal:define</sgmltag> on the same element.
</para>
<programlisting language="xml"><![CDATA[<ul id="user-info" phptal:cache="25m per object/id">…</ul>]]></programlisting>
             <para><sgmltag>&lt;ul></sgmltag> will be cached for 25 minutes, separately for each object ID.</para>

             <section id="cache-refresh"><title>Instant refreshing</title>

                 <para>Instead of clearing cache, it might be a better idea to put version or last modification timestamp in the <varname>per</varname> parameter. This will cause cached template to be refreshed as soon as version/timestamp changes and no special cache clearing will be neccessary.</para>
<programlisting language="xml"><![CDATA[<div phptal:cache="100d per php:news.id . news.last_modified_date">…</div>]]></programlisting>

                 </section>


<section id="cache-limits"><title>Limitations:</title>
            
            
            <itemizedlist>
              <listitem><para>
                  <sgmltag>phptal:cache</sgmltag> blocks can be nested, but outmost block will cache other blocks regardless of their freshness. </para></listitem><listitem><para>You cannot use <sgmltag>metal:fill-slot</sgmltag> inside elements with <sgmltag>phptal:cache</sgmltag>.</para></listitem><listitem><para>
  </para></listitem></itemizedlist>
                  

</section>

            </section>


      <section id="phptal-tales">
        <title><sgmltag>phptal:tales</sgmltag></title>

        <para>
        This attribute allows us to change the behaviour of <acronym>PHPTALES</acronym>.  The 
        default behaviours is to interpret attribute expressions in a 
        very <acronym>ZPT</acronym> way. But sometimes you just would like to have <acronym>PHP</acronym> 
        there, and you end up using php: modifier everywhere.
        </para>

        <para>
        Another problem concerning <acronym>PHPTALES</acronym> is the way <acronym>PHPTAL</acronym> has to 
        interpret paths. For example, 
        <varname>myobject/mymethod/property/10/othermethod/hashkey</varname> takes relatively long to 
        interpret (but don't worry about this too much – don't optimize until you find that it is <emphasis>really</emphasis> a problem with performance!)
        </para>
  
        <para>
        <acronym>PHPTAL</acronym> has (at runtime) to take myobject and discover that it
        is an object; find out that 'mymethod' is a method of this
        object (rather than a variable), and then to call it; explore
        the result to determine that it is an object with a property; find that its value is an array; find the 'ten'
        element of this array, and determine that it is an object;
        decide that othermethod is a method of this object (rather
        than a variable), and get the result of its execution; find
        that it is an object, and then retrieve the value
        for the key 'hashkey'.
        </para>

        <para>
        Of course this was an extreme example and most of the time we 
        don't care, because the process is fast enough. But what if this 
        very long path is called inside a big <sgmltag>tal:repeat</sgmltag>? D'oh!  
        <sgmltag>phptal:tales</sgmltag> can help us here:
        </para>

        <programlisting language="xml"><![CDATA[<html>
  <body>
    <table phptal:tales="php">
      <tr tal:repeat="myobject document.getChildren()">
        <td
          tal:content="myobject.mymethod().property[10].otherMethod().hashkey"></td>
      </tr>
    </table>
  </body>
</html>
]]></programlisting>

        <para>
        Please note that the above example does the same as:
        </para>

        <programlisting language="xml"><![CDATA[<html>
  <body>
    <table>
      <tr tal:repeat="myobject php:document.getChildren()">
        <td 
          tal:content="php:myobject.mymethod().property[10].otherMethod().hashkey"></td>
      </tr>
    </table>
  </body>
</html>
]]></programlisting>

        <para>
        'php:' modifier is explained in its own chapter.
        </para>
      </section>
      
    </section><!-- end of <acronym>PHPTAL</acronym> namespace -->
  
    <section id="phptal-blocks">
      <title><sgmltag>tal:block</sgmltag></title>

      <para>
      <sgmltag>tal:block</sgmltag> is a syntactic sugar for elements which contains many <acronym>TAL</acronym> 
      attributes which are not to be echoed.
      </para>

      <programlisting language="xml"><![CDATA[<tal:block define="myvar string:Some value"/>
]]></programlisting>

      <para>
      is the same as:
      </para>

      <programlisting language="xml"><![CDATA[<span tal:define="myvar string:Some value" tal:omit-tag=""/>
]]></programlisting>

      <para>
      Another example:
      </para>

      <programlisting language="xml"><![CDATA[<tal:block condition="someCondition" repeat="item someRepeat">
  <div metal:use-macro="x"/>
</tal:block>
]]></programlisting>

      <para>
      is the same as:
      </para>

      <programlisting language="xml"><![CDATA[<div tal:omit-tag=""
     tal:condition="someCondition"
     tal:repeat="item someRepeat">
  <div metal:use-macro="x"/>
</div>
]]></programlisting>
      
    </section><!-- end of *:block -->

    <section id="phptales">
      <title><acronym>PHPTALES</acronym></title>
      
      <para>
      <acronym>PHPTALES</acronym> is the expression syntax used inside tal, metal, <acronym>PHPTAL</acronym> 
      attributes. From above examples, you should have seen some
      <acronym>PHPTALES</acronym> examples (string:, php:, not:, …). This chapter 
      describes the usage of <acronym>PHPTALES</acronym> in templates.
      </para>

      <para>
      The value of a <acronym>TAL</acronym> attribute may contain more than one expression 
      (ex: <sgmltag>tal:define</sgmltag>), in which case each expression must be separated 
      from the next one with a '<sgmltag>;</sgmltag>' character.
      </para>

      <section id="tales-path">
        <title>path:</title>

        <para>
        This is the default modifier used in <acronym>TAL</acronym> expression when no 
        other modifier is specified.
        </para>

        <para>
        The following lines will give the same result:
        </para>

        <programlisting language="xml"><![CDATA[<span tal:content="data/user/name"/>
<span tal:content="path:data/user/name"/>
<span>${data/user/name}</span>
]]></programlisting>
        
        <para>
        Inside the template or inside expression strings, you can refer 
        to a context variable using its path in the form 
        ${path/to/my/variable}
        </para>

        <programlisting language="xml"><![CDATA[<h1>${document/title}</h1>
<span tal:replace="string:welcome ${user/name}, 
this page has been readed ${page/countRead} times"/>
]]></programlisting>
      </section>

      <section id="conditional">
        <title>Conditional statements</title>

        <para>
        As '&lt;' and '&gt;' should be removed from attribute
        expression. <acronym>PHPTAL</acronym> provides some equivalent good old
        text-comparison operators.
        </para>

        <para>
        These statements will mostly appear in <sgmltag>tal:condition</sgmltag> attributes, 
        and in php: expressions.
        </para>

        <itemizedlist>
          <listitem><para>
          &lt; : LT (less than)
          </para></listitem>
          <listitem><para>
          &gt; : GT (greater than)
          </para></listitem>
          <listitem><para>
          &lt;= : LE (less or equal)
          </para></listitem>
          <listitem><para>
          &gt;= : GE (greater or equal)
          </para></listitem>
        </itemizedlist>
      </section>

      <section id="tales-string">
        <title>string:</title>

        <para>
        Because expressions are separated by a ';' character, and 
        because '$' marks the start of a path, you must use:
        </para>

        <itemizedlist>
          <listitem><para>
          '<literal>;;</literal>' when you want to insert a real ';' character in a string,
          </para></listitem>
          <listitem><para>
          '<literal>$$</literal>' when you want to insert a real '$' character in a string.
          </para></listitem>
        </itemizedlist>

        <programlisting language="xml"><![CDATA[<span tal:replace="string:this is a $$100 page"/>
string:foo $bar baz       <!-- will replace $bar -->
string:foo $$bar baz      <!-- no interpolation -->
string:foo ; php:doFoo()  <!-- two different expressions -->
string:foo ;; php:doFoo() <!-- only string -->
]]></programlisting>
      </section>

      <section id="tales-php">
        <title>php:</title>

        <para>
        This expression evaluates what follows as a regular <acronym>PHP</acronym> 
        expression except that '-&gt;' are replaced by dots '.' and 
        variable names does not need to be prefixed with a dollar '$' 
        sign.
        </para>

        <para>
        A dot '.' separated from the rest of expression by spaces is 
        assumed to be a concatenation sign.
        </para>

        <programlisting><![CDATA[php:htmlentities(foo)
php:'string ${varReplaced}'
php:'string ${some.path().to[0].var}'
php:NOT foo OR (bar GT baz)
php:a + b
php:array('a', 'b', 'c')
php:range(0, 90)
php:foo . a.b.c(e) . htmlentities(SomeClass::staticMethod()) 
php:SomeClass::ConstOfClass
php:SomeClass::$staticVar
]]></programlisting>
      
        <para>
        php: should be used with care and won't be needed in 80% of
        your templates but sometimes you will need to invoke some
        special <acronym>PHP</acronym> method to be certain whether a user is logged in, or
        to retrieve specific complex data depending on some conditions,
        dynamically inside the template.
        </para>
      </section>

      <section id="tales-not">
        <title>not:</title>

        <para>
        This expression is a boolean one, useful in <sgmltag>tal:condition</sgmltag> 
        statements.
        </para>

        <programlisting language="xml"><![CDATA[<span tal:condition="not: logged">not logged</span>
]]></programlisting>
      </section>

      <section id="tales-exists">
        <title>exists:</title>

        <para>
        This expression returns <code>true</code> if the path specified after it exists, and <code>false</code> otherwise. It is analogous to <acronym>PHP</acronym>'s <code>isset()</code>.</para>
            
        <para>
        Normally using a path which doesn't exist throws an error like "Cannot find variable '<varname>foo</varname>' in current scope". Thus, uncertain paths must be checked first:
        </para>
              
        <programlisting language="xml"><![CDATA[<span tal:condition="exists:user/preferences" tal:content="user/preferences">
  Use user/preferences here if defined
</span>
]]></programlisting>
      
      </section>

      <section id="tales-default">
        <title>default</title>

        <para>
        This is not an expression but a keyword, allowing template 
        designers to keep the content of a tag as an alternative value 
        if an error occurs, or if something is not defined.
        </para>

        <programlisting language="xml"><![CDATA[<span tal:define="myVar path/to/possible/var | default">
  default my var value
</span>

<span tal:content="some/var | other/path | default">
  no some/var and no other/path found here
</span>

<a href="unknown.xhtml" title="Unknown page"
   tal:attributes="href item/href | default; title item/title | default"
   tal:content="item/title | default">Unknown page</a>
]]></programlisting>

        <para>
        Above examples introduce the '<code>|</code>' character that allows the 
        definition of alternatives for defines or prints.
        </para>
      </section>

      <section id="tales-structure">
        <title>structure</title>

        <para>
        This is not an expression modifier but a keyword.
        </para>

        <para>
        While printing variables inside <acronym>PHPTAL</acronym> templates, you will
        have noticed that <acronym>PHPTAL</acronym> encodes each variable to ensure the
        validity of the output document.
        </para>
 
        <para>
        Sometimes, you may use <acronym>HTML</acronym>/<acronym>XML</acronym> variables which must be echoed as is.
        </para>

        <programlisting language="xml"><![CDATA[<h1 tal:content="structure document/title"/>
<span tal:replace="structure document/content"/>
]]></programlisting>

        <para>
        In above examples, we assume that <code>$document->title</code> and 
        <code>$document->content</code> are variables containing preformated <acronym>HTML</acronym> 
        which must be echoed as is.
        </para>
      </section>

      <section id="expression-chains">
        <title>Expression chains</title>

        <para>
        An expression chain is a list of expressions separated by '<code>|</code>' 
        characters.
        </para>

        <para>
        While evaluating expressions separated by '<code>|</code>', <acronym>PHPTAL</acronym> will stop 
        its evaluation when an expression value is not null and no error 
        was raised while evaluating the expression.
        </para>

        <para>
        As a string: expression is always true, string: always terminates 
        an expression chain whatever expression may follow.
        </para>

        <para>
        You can use <code>php:</code> expressions inside expression chains, like any 
        other expression.
        </para>

        <programlisting language="xml"><![CDATA[<h1 tal:content="page/title | page/alternativeTitle | php:get_default_title()" />]]></programlisting>
      </section>
 
    </section><!-- end of PHPTALES -->
  </article>

  <article id="phpintegration">
    <title><acronym>PHP</acronym> Integration</title>
    
    <para>
    This section is aimed at <acronym>PHP</acronym> developers and explains how to use and 
    customize <acronym>PHPTAL</acronym> behaviours for simple and advanced usage.
    </para>

    <itemizedlist>
      <listitem><para>
      <classname>PHPTAL</classname>: the main <acronym>PHPTAL</acronym> class. It is used to load and execute templates.
      </para></listitem>
      <listitem><para>
      <classname>PHPTAL_Filter</classname>: filtering template sources and <acronym>PHPTAL</acronym> output.
      </para></listitem>
      <listitem><para>
      <classname>PHPTAL_Trigger</classname>: handles output of elements with <sgmltag>phptal:id</sgmltag>.
      </para></listitem>
      <listitem><para>
      <classname>PHPTAL_TranslationService</classname>: for replacing the built-in <constant>gettext</constant> support 
      with your own internationalization system.
      </para></listitem>
    </itemizedlist>

    <section id="constants">
      <title>Constants</title>

      <para>
      After the inclusion of <acronym>PHPTAL</acronym> library, some defines will be 
      created in <acronym>PHP</acronym> context, all these defines come from <filename>PHPTAL.php</filename> 
      file:
      </para>

      <itemizedlist>
        <listitem><para>
        <classname>PHPTAL_VERSION</classname>: version of <acronym>PHPTAL</acronym> library installed on your
        system (in format: X.X.X)
        </para></listitem>
      </itemizedlist>

      <para>
      In older versions of there were constants for configuration. They have been replaced with methods.
      </para>
  </section>
  <section id="configuration">
      <title>Configuration methods</title>
      
      <para><acronym>PHPTAL</acronym> tries to use best defaults possible and you shouldn't <emphasis>need</emphasis> to change any of the settings.</para>
      
      <para>All of these are methods of the <classname>PHPTAL</classname> class. <methodname>set<replaceable>*</replaceable></methodname> methods return instance of their class, so you can chain them:</para>
        <programlisting><![CDATA[<?php
  echo $phptal->setPhpCodeDestination('/tmp/phptal')->setOutputMode(PHPTAL::XML)->setTemplate('tpl.zpt')->execute();
?>]]></programlisting>
<para>is the same as:</para>
        <programlisting><![CDATA[<?php
  $phptal->setPhpCodeDestination('/tmp/phptal');
  $phptal->setOutputMode(PHPTAL::XML);
  $phptal->setTemplate('tpl.zpt');
  echo $phptal->execute();
?>]]></programlisting>

      <itemizedlist>
          <listitem><para><methodname>setEncoding(<replaceable>encoding</replaceable>)</methodname>: Specify what encoding your templates use. The default is <acronym>UTF-8</acronym>.</para></listitem>
          <listitem><para><methodname>setOutputMode(<replaceable>mode</replaceable>)</methodname>: If given <constant>PHPTAL::XHTML</constant> (the default), will output elements like <sgmltag>&lt;img></sgmltag>, <sgmltag>&lt;link></sgmltag>, and attribtes like <sgmltag>checked</sgmltag>, <sgmltag>selected</sgmltag> according to XHTML specification, including <acronym>HTML</acronym> compatibility guidelines. Use <constant>PHPTAL::XML</constant> if you want to output other <acronym>XML</acronym> formats, like Atom or <acronym>RSS</acronym>.</para></listitem>
          <listitem><para><methodname>setTemplateRepository(<replaceable>string_or_array</replaceable>)</methodname>: Specifies where to look for templates. If given a string, it adds it to the list of paths searched. If given array, it replaces the list.</para>
              <para>
                  This doesn't mean all your files need to be in the root
                  directory, you can use sub folders to organize your template
                  designer's work.  It's just a shortcut which will allow you to
                  reference templates without specifying the real path, but
                  instead their relative path within the repository.
              </para>
          </listitem>
          <listitem><para><methodname>setPhpCodeDestination(<replaceable>path</replaceable>)</methodname>: To tell <acronym>PHPTAL</acronym> where to store its intermediate (temporary) <acronym>PHP</acronym> files. By default it uses directory given by  <acronym>PHP</acronym>'s <methodname>sys_get_tmp_dir()</methodname>, which usually is '<filename>/tmp/</filename>' directory.</para></listitem>
          <listitem><para><methodname>setPhpCodeExtension(<replaceable>string</replaceable>)</methodname>: What filename extension should be used for intermediate <acronym>PHP</acronym> files. The default is <filename>php</filename> and frankly, there's no reason to change it.</para></listitem>
          <listitem><para><methodname>setCacheLifetime(<replaceable>num_days</replaceable>)</methodname>: Maximum number of days intermediate files and fragments cached with <sgmltag>phptal:cache</sgmltag> should be kept.</para></listitem>
          
          <listitem><para><methodname>setForceReparse(<replaceable>boolean</replaceable>)</methodname>: forces reparsing of all templates all the time. This slows down <acronym>PHPTAL</acronym> very much, it should be used only for testing and debugging. Never enable this on production servers.</para></listitem>
          </itemizedlist>     
          
          <para>There are other <methodname>set<replaceable>*</replaceable></methodname> methods for filters, internationalisation, etc. They have been described in other sections of this manual.</para>
          
    </section>

    <section id="phptal-class">
      <title>class <classname>PHPTAL</classname></title>
    
      <para>
      This is the main library class for you to use.
      </para>

      <para>
      The most common method of use:
      </para>

      <programlisting><![CDATA[<?php

// include the library
require_once 'PHPTAL.php';

// instantiate a new PHPTAL object using specified template file
$tpl = new PHPTAL('mytemplate.xhtml');

// setting some template context variables
$tpl->title  = 'my title';
$tpl->values = array(1,2,3,4);
$tpl->user   = new User('Joe');

// execute the template and echo the result in a 'secure' way
try {
    echo $tpl->execute();
}
catch (Exception $e){
    echo "Exception thrown while processing template\n";
    echo $e;
}
?>
]]></programlisting>

      <para>
      You can perfectly well choose to specify the template source 
      after setting context variables.
      </para>

      <programlisting><![CDATA[<?php
…
$tpl = new PHPTAL();

// it is a matter of taste but you can use the set() method instead of 
// setting context using PHPTAL::__set() like above
$tpl->set('title', 'my title');
$tpl->set('values', array(1,2,3,4));
$tpl->set('user', new User('Joe'));

$tpl->setTemplate('mytemplate.xhtml');
…
?>
]]></programlisting>

      <para>
      You can also decide to use a generated string as the template
      source instead of using an existing template file:
      </para>

      <programlisting><![CDATA[<?php

$src = <<<EOS
<html>
  <head>
  <title tal:content="title">my title</title>
  </head>
  <body>
    <h1 tal:content="title">my title</h1>
  </body>
</html>
EOS;

require_once 'PHPTAL.php';
$tpl = new PHPTAL();
$tpl->setSource($src);
$tpl->title = 'this is my title';
try {
    echo $tpl->execute();
}
catch (Exception $e){
    echo $e;
}

?>
]]></programlisting>

      <para>
      In the above example, because <acronym>PHPTAL</acronym> requires a template source
      idenfifier (usually the template file realpath), <acronym>PHPTAL</acronym> will use the md5
      of the <varname>$src</varname> parameter as a unique identifier. You may decide to force the 
      identifier using a second <methodname>setSource()</methodname> argument:
      </para>

      <programlisting><![CDATA[<?php
$src = <<<EOS
<html>
  <head>
  <title tal:content="title">my title</title>
  </head>
  <body>
    <h1 tal:content="title">my title</h1>
  </body>
</html>
EOS;

require_once 'PHPTAL.php';
$tpl = new PHPTAL();

// because the source is contained in this file and won't be modified unless
// this file is modified, it is 'faster' to specify __FILE__ as the unique 
// source identifier, thus no md5 of $src will be done on each call.
$tpl->setSource($src, __FILE__);
$tpl->title = 'this is my title';
try {
    echo $tpl->execute();
}
catch (Exception $e){
    echo $e;
}

?>
]]></programlisting>
      
    </section>
   
    <section id="filter-interface">
      <title>interface <classname>PHPTAL_Filter</classname></title>

      <para>
      This interface allows you to automatically filter templates sources 
      (pre-filters) or <acronym>PHPTAL</acronym> result (post-filters).
      </para>

      <para>
      Pre filters are invoked before the template parsing and won't be 
      invoked until the source template file is modified.
      </para>

      <para>
      Post filters are invoked after each template execution.
      </para>

      <programlisting><![CDATA[<?php
require_once 'PHPTAL.php';
    
class MyPreFilter implements PHPTAL_Filter {
    public function filter($source){
        return $source;
    }
}

class MyPostFilter implements PHPTAL_Filter {
    public function filter($xhtml){
        return $xhtml;
    }
}

$tpl = new PHPTAL('mytemplate.xhtml');
$tpl->setPreFilter(new MyPreFilter());
$tpl->setPostFilter(new MyPostFilter());
echo $tpl->execute();
?>
]]></programlisting>

      <para>
      You can set only one pre-Filter and one post-Filter using 
      set<replaceable>*</replaceable>Filter. If you have more than one filter to chain, you can 
      wrap them into a single class, implementing the <classname>PHPTAL_Filter</classname> 
      interface, which would invoke the filter's chain.
      </para>

      <programlisting><![CDATA[<?php
require_once 'PHPTAL.php';

class FilterChain implements PHPTAL_Filter {
    private $_filters = array();

    public function add(PHPTAL_Filter $filter){
        $this->_filters[] = $filter;
    }

    public function filter($source){
        foreach($this->_filters as $filter){
            $source = $filter->filter($source);
        }
        return $source;
    }
}

$myfilter = new FilterChain();
$myfilter->add(new CommentFilter());  // imaginary filter
$myfilter->add(new TidyFilter());     // imaginary filter

$tpl = new PHPTAL('mytemplate.xhtml');
$tpl->setPostFilter($myFilter);
echo $tpl->execute();
?>
]]></programlisting>
    </section>

    <section id="trigger-interface">
      <title>interface <classname>PHPTAL_Trigger</classname></title>

      <para>
      The <sgmltag>phptal:id</sgmltag> attribute was added into the <acronym>PHPTAL</acronym> for the PHP5
      version to replace the old <classname>PHPTAL_Cache</classname> interface and to abstract
      it a little more.
      </para>

      <para>
      When a <sgmltag>phptal:id</sgmltag> is reached, <acronym>PHPTAL</acronym> will look in its triggers list
      for a matching id and will invoke the trigger start() and end() 
      methods before entering the element, and just after it.
      </para>

      <para>
      If the <constant>PHPTAL_Trigger::start()</constant> methods returns 
      <constant>PHPTAL_Trigger::SKIPTAG</constant>, <acronym>PHPTAL</acronym> will ignore the element and its 
      content (start() may echo something to replace it).
      </para>

      <para>
      If your trigger wants the element and its content to be executed, 
      you'll have to return <constant>PHPTAL_Trigger::PROCEED</constant>.
      </para>

      <para>
      The <constant>PHPTAL_Trigger::end()</constant> will be called after the element 
      (whether it has been executed or not). This allows you to build 
      cache systems using ob_start() in start() and ob_get_contents(), 
      ob_end_clean() in end().
      </para>

      <programlisting language="xml"><![CDATA[<html>
  …
  <div>
    …
    foo bar baz <span tal:replace="id"/> foo bar baz
    …
  </div>
  …
</html>
]]></programlisting>

      <para>
      For some reason we decide the div block requires to be cached. We 
      introduce a <sgmltag>phptal:id</sgmltag> into the template:
      </para>

      <programlisting language="xml"><![CDATA[<html>
  …
  <div phptal:id="somePossiblyUniqueKeyword">
    …
    foo bar baz <span tal:replace="id"/> foo bar baz
    …
  </div>
  …
</html>
]]></programlisting>

      <para>
      Then we write our trigger which will cache the div content:
      </para>
 
      <programlisting><![CDATA[<?php
require_once 'PHPTAL.php';
require_once 'PHPTAL/Trigger.php';

class CacheTrigger implements PHPTAL_Trigger
{
    public function start($phptalid, $tpl)
    {
        // this cache depends on 'id' which must appears in
        // the template execution context
        $this->_cachePath = 'cache.' . $tpl->getContext()->id;

        // if already cached, read the cache and tell PHPTAL to
        // ignore the tag content
        if (file_exists($this->_cachePath)){
            $this->_usedCache = true;
            readfile($this->_cachePath);
            return self::SKIPTAG;
        }
        
        // no cache found, we start an output buffer and tell
        // PHPTAL to proceed (ie: execute the tag content)
        $this->_usedCache = false;
        ob_start();
        return self::PROCEED;
    }

    // Invoked after tag execution
    public function end($phptalid, $tpl)
    {
        // end of tag, if cached file used, do nothing
        if ($this->_usedCache){
            return;
        }

        // otherwise, get the content of the output buffer
        // and write it into the cache file for later usage
        $content = ob_get_contents();
        ob_end_clean();
        echo $content;

        $f = fopen($this->_cachePath, 'w');
        fwrite($f, $content);
        fclose($f);
    }

    private $_cachePath;
    private $_usedCache;
}
?>
]]></programlisting>
    
      <para>
      The key here is to return from start() with either <constant>SKIPTAG</constant> or 
      <constant>PROCEED</constant>.
      </para>
  
      <para>
      When <constant>SKIPTAG</constant> is returned, <acronym>PHPTAL</acronym> will just ignore the tag and call 
      end().  This usually means that the trigger takes the hand in
      deciding what to show there.
      </para>
  
      <para>
      When <constant>PROCEED</constant> is returned, <acronym>PHPTAL</acronym> will execute the tag and its 
      content as usual, then call end(). This allows our cache class to 
      play with output buffers to execute the tag once and to store the 
      result in a file which will be used in later calls.
      </para>

      <para>
      To install our trigger we use:
      </para>

      <programlisting><![CDATA[<?php
require_once 'PHPTAL.php';
require_once 'CacheTrigger.php'; // our custom trigger

$trigger = new CacheTrigger();

$tpl = new PHPTAL('test.xhtml');
    
// this trigger will only be called for phptal:id="triggerId"
$tpl->addTrigger('somePossiblyUniqueKeyword', $trigger);

$tpl->id = 1;

echo $tpl->execute();

?>
]]></programlisting>

      <para>
      You can add as many triggers as you like to your templates.  A 
      generic cache trigger may also handle more than one <sgmltag>phptal:id</sgmltag>…  
      etc…
      </para>
    </section>

    <section id="translation-interface">
      <title>interface <classname>PHPTAL_TranslationService</classname></title>

      <para>
      <acronym>PHPTAL</acronym> comes with a default gettext translation service, as shown 
      in another section. For some reason you may prefer to implement 
      your own service of translation.
      </para>

      <para>
      The <classname>PHPTAL_TranslationService</classname> interface is here to serve your 
      needs.
      </para>

      <para>
      The usage of your service will be the same as the   
      <classname>PHPTAL_GetTextTranslator</classname>.
      </para>

      <programlisting><![CDATA[$tpl->setTranslator($yourOwnTranslatorInstance);
]]></programlisting>
      
      <para>
      Your implementation must define the following methods:
      </para>

      <section id="i18n-setlanguage">
        <title>method setLanguage(…)</title>

        <para>
        This method may be called by the template to change the current 
        output language.
        </para>

        <para>
        Its arguments are a list of possible languages (use 
        func_get_args() to get the argument array). The first known 
        language should be used by your service.
        </para>

        <programlisting><![CDATA[<?php
require_once 'PHPTAL/TranslationService.php';

class MyTranslator implements PHPTAL_TranslationService {
…
    public function setLanguage(){
        $langs = func_get_args();
        foreach($langs as $lang){
            // if $lang known use it and stop the loop
            $this->_currentLang = $lang;
            return;
        }
    }
    …
    private $_currentLang;
}
?>
]]></programlisting>
      </section>

      <section id="i18n-usedomain">
        <title>method useDomain($domain)</title>

        <para>
        If you decided to store your translations into separate files, 
        one for each application, for example, this method allows you to 
        select the translation domain from your templates (<sgmltag>i18n:domain</sgmltag>).
        </para>

        <programlisting><![CDATA[<?php
require_once 'PHPTAL/TranslationService.php';

class MyTranslator implements PHPTAL_TranslationService {
    …
    public function useDomain($domain){
        if (!array_key_exists($domain, $this->_domains)){
            $file = "domains/$this->_currentLang/$domain.php";
            $this->_domains[$domain] = include($file);
        }
        $this->_currentDomain = $this->_domains[$domain];
    }
    …
    private $_currentDomain;
    private $_domains = array();
}
?>
]]></programlisting>

        <para>
        The above example is a possible translation solution where keys 
        are stored in <acronym>PHP</acronym> files which return an associative array of 
        key =&gt; translation.
        </para>
      </section>

      <section id="i18n-setvar">
        <title>method setVar($key,$value)</title>
  
        <para>
        This method matches <sgmltag>i18n:name</sgmltag> calls. It builds an interpolation 
        context for later translate calls.
        </para>

        <programlisting><![CDATA[<?php
require_once 'PHPTAL/TranslationService.php';

class MyTranslator implements PHPTAL_TranslationService {
    …
    public function setVar($key, $value){
        $this->_context[$key] = $value;
    }
    …
    private $_context = array();
}
?>
]]></programlisting>
      </section>
    
      <section id="i18n-translatekey">
        <title>method translate($key)</title>

        <para>
        The last and most important method to implement, it asks your 
        service to translate the specified key for the currently selected 
        language.
        </para>

        <programlisting><![CDATA[<?php
require_once 'PHPTAL/TranslationService.php';

class MyTranslator implements PHPTAL_TranslationService {
    …
    public function translate($key){
        $value = $this->_currentDomain[$key];
        
        // interpolate ${myvar} using context associative array
        while (preg_match('/\${(.*?)\}/sm', $value, $m)){
            list($src,$var) = $m;
            if (!array_key_exists($var, $this->_context)){
                $err = sprintf('Interpolation error, var "%s" not set', 
                               $var);
                throw new Exception($err);
            }
            $value = str_replace($src, $this->_context[$var], $value);
        }
        
        return $value;
    }
    …
}
?>
]]></programlisting>
      </section>


        <section id="i18n-setencoding">
          <title>method setEncoding($encoding)</title>

          <para>
              <acronym>PHPTAL</acronym> class calls this method to inform your translation service what encoding is used by the template. <code>translate()</code> method should return strings in that encoding. If you always use the same encoding for templates and translation files (i.e. UTF-8), you can leave this method empty.
          </para>
        </section>
    </section> <!-- end of PHPTAL_TranslationService -->


    <section id="gettext">    <?dbhtml stop-chunking?>  
      <title>Working with gettext</title>
      
      <para>
      <literal>gettext</literal> is a standard <acronym>GNU</acronym> internationalization 
      / translation system which can be used with <acronym>PHP</acronym> and which is 
      supported by <acronym>PHPTAL</acronym>.
      </para>

      <para>
      The usage of <literal>gettext</literal> is simple but you will 
      have to perform some tests to be sure everything works fine on your
      system.
      </para>

      <para>
      First, <acronym>PHP</acronym> must be compiled with the 
      <parameter>--with-gettext</parameter> flag. See <acronym>PHP</acronym> documentation 
      for how to do this.
      </para>

      <para>
      You can test your installation using following peace of code:
      </para>

      <programlisting role="php"><![CDATA[
//
// test if gettext extension is installed with php
//

if (!function_exists("gettext")) 
{
    echo "gettext is not installed\n";
} 
else 
{
    echo "gettext is supported\n";
}
]]></programlisting>

      <section id="i18n-directory"><?dbhtml stop-chunking?>
        <title>Creating the translation directory structure</title>

        <para>
        The <acronym>PHP</acronym> gettext extension requires a specific structure which 
        will contain your translation files. 
        </para>

        <programlisting><![CDATA[/path/to/your/translation_root/en_US/LC_MESSAGES/
/path/to/your/translation_root/en_GB/LC_MESSAGES/
/path/to/your/translation_root/fr_FR/LC_MESSAGES/
/path/to/your/translation_root/es_ES/LC_MESSAGES/
… and so on …
]]></programlisting>

        <para>
        The language code is composed of two characters defining the 
        language itself (en, fr, es, …) and two characters defining 
        the country (US, GB, FR, ES, …).
        </para>

        <para>
        The directory pattern is:
        </para>

        <programlisting><![CDATA[<path_to_where_you_want>/<ll_CC>/LC_MESSAGES/
]]></programlisting>

      </section>

      <section id="po-files"><?dbhtml stop-chunking?>
        <title>Portable Object files</title>

        <para>
        PO files are plain text files that contain your translation. 
        You can safely edit them by hand.
        </para>

        <para>
        po minimalistic example (<filename>en_US/LC_MESSAGES/mydomain.po</filename>):
        </para>

        <programlisting><![CDATA[msgid ""
msgstr ""
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Simple test"
msgstr "A small sentence in english"
]]></programlisting>

        <para>
        Once edited, each PO file must be indexed using:
        </para>

        <programlisting><![CDATA[msgfmt mydomain.po -o mydomain.mo
]]></programlisting>

        <para>
        This command won't work if you don't have gettext tools 
        installed on your system.
        </para>

        <para>
        This will produce a MO file (machine object) indexing your 
        translation for quick access.
        </para>

        <para>
        Then you have to translate this file in other languages.
        </para>

        <para>
        po minimalistic example (fr_FR/LC_MESSAGES/mydomain.po):
        </para>
        
        <programlisting><![CDATA[msgid ""
msgstr ""
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"

msgid "Simple test"
msgstr "Une petite phrase en français"
]]></programlisting>

        <para>
        The translation file must also be indexed:
        </para>
        
        <programlisting><![CDATA[msgfmt mydomain.po -o mydomain.mo
]]></programlisting>

      </section>

      <section id="i18n-domains">
        <title>Translation Domain</title>

        <para>
        The domain is matched against your translation file names. In
        above examples we used 'mydomain' as domain name.
        </para>

        <para>
        You can have more than one domain for the same application, it 
        can enhance gettext's performance to split your application 
        translations in more than one file.
        </para>
      </section>

      <section id="php-in-phptal">
        <title><acronym>PHP</acronym> usage in <acronym>PHPTAL</acronym></title>

        <programlisting><![CDATA[<?php
require_once 'PHPTAL.php';
require_once 'PHPTAL/GetTextTranslator.php';

try {
    $tr = new PHPTAL_GetTextTranslator();
    
    // set language to use for this session (first valid language will 
    // be used)
    $tr->setLanguage('en_GB.utf8', 'en_GB');
    
    // register gettext domain to use
    $tr->addDomain('mydomain', '/path/to/your/translation_root');

    // specify current domain
    $tr->useDomain('mydomain');

    $tpl = new PHPTAL('mytemplate.xhtml');

    // tell PHPTAL to use our translator
    $tpl->setTranslator($tr);
}
catch (Exception $e){
    echo $e;
}
]]></programlisting>
      </section>

      <section id="var-interpolation">
        <title>Variable interpolation</title>

        <para>
        The <acronym>I18N</acronym> namespace allows some variable interpolation in your 
        translations.
        </para>

        <programlisting language="gettext"><![CDATA[# english 
msgid "welcome"
msgstr "Welcome ${name} you have ${n} mails!"

# french  
msgid "welcome"
msgstr "Bienvenue ${name} vous avez recu ${n} messages!"
]]></programlisting>

        <para>
        A template can use this interpolation as follows:
        </para>

        <programlisting language="xml"><![CDATA[<span i18n:translate="welcome">
  Welcome
  <span i18n:name="name" tal:replace="user/name"/>
  you currently have
  <span i18n:name="n" tal:replace="user/unreadeMails"/>
  unread messages!
</span>
]]></programlisting>

        <para>
        Because <sgmltag>i18n:translate</sgmltag> contains a value 'welcome', the template 
        data will be ignored and the message given by gettext will be
        used instead.
        </para>

      </section>

    </section>

    <section id="custom-modifiers">
      <title>Creating custom expression modifiers</title>

      <para>
      <acronym>PHPTAL</acronym> comes with some basic expression modifiers (<code>not:</code>, <code>exists:</code>, 
      <code>string:</code>, <code>php:</code>, <code>path:</code>).
      </para>

      <para>
      These modifiers are defined by <acronym>ZPT</acronym> specifications but <acronym>PHPTALES</acronym> can 
      be extended with your own modifiers to manipulate strings, date, 
      money numbers, objects, whatever…
      </para>

      <para>
      The aim of a modifier is to return some <acronym>PHP</acronym> code that will be 
      included in the template <acronym>PHP</acronym> source.
      </para>

      <para>
      Modifiers are used at parse time. If you change the behaviour of a
      modifier, you'll have to delete generated <acronym>PHP</acronym> files and reparse 
      all templates using it.
      </para>
  
      <para>
      Please note that modifiers produce code, and mustn't echo data!
      </para>

      <para>
      Any <acronym>PHP</acronym> function starting with "<constant>phptal_tales_</constant>" is usuable as a 
      modifier.
      </para>

      <para>
      Modifiers takes two arguments:
      </para>

      <itemizedlist>
        <listitem><para>
        $src: the source string after the "modifier:" keyword
        </para></listitem>
        <listitem><para> 
	  $nothrow: a boolean which determines whether exceptions may
	  be thrown or not by <constant>phptal_path()</constant> resolution. This boolean
	  must be propagated whenever you call another phptal_tales_<replaceable>*</replaceable>
	  modifier from within your own modifier. 
	</para></listitem>
      </itemizedlist>

      <para>
      For example, in the following <acronym>TAL</acronym> template,
      </para>

      <programlisting language="xml"><![CDATA[<span tal:replace="some-modifier: my/path/value"/>
]]></programlisting>

      <para>
      The src argument will be "<varname>my/path/value</varname>", and the <varname>$nothrow</varname> boolean 
      will be false, because <sgmltag>tal:replace</sgmltag> requires the path to be fully 
      resolvable.
      </para>

      <para>
      An expression like:
      </para>

      <programlisting language="xml"><![CDATA[<span tal:replace="some-modifier: my/path/value | other/path"/>
]]></programlisting>

      <para>
      Will use 2 modifiers:
      </para>

      <itemizedlist>
        <listitem><para>
        some-modifier: with "my/path/value" as $src argument and
         $nothrow set to true because an alternative exists
        </para></listitem>
        <listitem><para>
        path: with "other/path" as $src, and $nothrow set to false 
        because in case the alternative is not found, <sgmltag>tal:replace</sgmltag> will 
        be in trouble.
        </para></listitem>
      </itemizedlist>

      <para>
      Remember, path: is the implicit modifier used when no other 
      modifier is specified.
      </para>

      <para>
      Modifiers can use other modifiers to generate simpler php
      code. The example below shows this.
      </para>

      <programlisting><![CDATA[//
// This modifier will return a money formated string (XXX.XX)
//
// usage:
//
//      money: path/to/my/amount
//
// this modifier uses phptal_tales() function to generate the
// PHP code that will return the value of the modifier argument.
//
// in the example:
//
//      money: path/to/my/amount 
//
// the produced code will be something looking like:
//
//      sprintf("%01.2f", phptal_path($ctx->path, "to/my/amount"))
//
// This code will be included right into the template where needed.
//
// @param string $src
//      The expression string
// @param string $nothrow
//      A boolean indicating if exceptions may be throw by phptal_path if
//      the path does not exists.
// @return string
//      PHP code to include in the template
//
function phptal_tales_money( $src, $nothrow )
{
    // remove spaces we do not require here
    $src = trim($src); 
    return 'sprintf("%01.2f", '.phptal_tales($src, $nothrow).')';
}
]]></programlisting>

    </section>

  </article>
  
  <appendix id="sysadmin">
      <title>Note for system administrators</title>
      <para>
          <acronym>PHPTAL</acronym> functions by generating <acronym>PHP</acronym> files from the template's logic,
          this means that it needs a directory to store those generated files so
          they can be parsed by the <acronym>PHP</acronym> interpreter.
</para><para>
          By default <acronym>PHPTAL</acronym> will use the system's temp directory (via <acronym>PHP</acronym>'s
          <constant>sys_get_temp_dir()</constant> function if available) or will try to guess where
          it should be, <filename>/tmp</filename> on Unix like systems and <filename>c:\windows\temp</filename> on
          Microsoft ones, to store the compiled templates. The default
          destination can be changed to your liking by calling <methodname>setPhpCodeDestination()</methodname>
          method with the appropriate path.
          Be it the system's temp directory or a custom one, it needs to have
          its permissions setup as to allow the <acronym>PHP</acronym> running process (the Apache
          user if using mod_php or the cgi/fastcgi user otherwise) to create and
          update files in that directory.
</para><para>
          <acronym>PHPTAL</acronym> creates one file for each different template file and one file
          for each tag if using <sgmltag>phptal:cache</sgmltag>. It doesn't create separate files
          for macros (which are simply compiled as <acronym>PHP</acronym> functions inside the
          compiled template file).
          These files are automatically cleaned up once in a while, more
          specifically, each time a template is compiled there is random
          probability, controlled by <methodname>setCachePurgeFrequency()</methodname> method, which will
          just delete files older than set by <methodname>setCacheLifetime()</methodname> method.
          </para><para>
          Alternatively you can also schedule the deletion of old/unused files
          by running this from an Unix-like shell (e.g. in a cron job):
</para><programlisting>find /tmp/ -name tpl_\* \( -atime +1 -o -mtime +14 \) -exec rm -v {} \;</programlisting>
</appendix>
  <appendix id="usefullinks">
    <title>Useful links</title>

    <itemizedlist>
      <listitem><para>
      <ulink url="http://www.zope.org/Wikis/Projects/ZPT/"><acronym>ZPT</acronym></ulink> 
      Zope Page Template front page,
      </para></listitem>
      <listitem><para>
      <ulink 
url="http://www.zope.org/Wikis/DevSite/Projects/ZPT/TAL/"><acronym>TAL</acronym></ulink> 
the Template Attribute Language page,
      </para></listitem>
      <listitem><para>
      <ulink 
url="http://www.zope.org/Wikis/DevSite/Projects/ZPT/METAL"><acronym>METAL</acronym></ulink> 
is the Macro Expansion of TAL,
      </para></listitem>
      <listitem><para>
      <ulink 
url="http://www.zope.org/Wikis/DevSite/Projects/ZPT/TALES"><acronym>TALES</acronym></ulink> 
the <acronym>TAL</acronym> Expression Syntax.
      </para></listitem>
    </itemizedlist>
  </appendix>

  <appendix id="greetings">
    <title>Greetings</title>

    <para>Big thanks goes to:</para>
    
    <itemizedlist>
      <listitem><para>
      <acronym>ZPT</acronym> team, who made these useful specifications,
      </para></listitem>
      <listitem><para>
      The <acronym>PHPTAL</acronym> community for their support, help and reports,
      </para></listitem>
      <listitem><para>
      Jean-Michel Hiver, who 'forced' me to look at them,
      </para></listitem>
      <listitem><para>
      Olivier Parisy, the first enthusiastic <acronym>PHPTAL</acronym> user and bug finder,
      </para></listitem>
    </itemizedlist>
  </appendix>
</book>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>interface PHPTAL_Cache</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><LINK
REL="HOME"
TITLE="PHPTAL - PHP Template Attribute Language"
HREF="index.html"><LINK
REL="UP"
TITLE="PHP Integration "
HREF="phpapi.html"><LINK
REL="PREVIOUS"
TITLE="class PHPTAL "
HREF="phptal.phptal.html"><LINK
REL="NEXT"
TITLE="interface PHPTAL_Filter"
HREF="phptal.filter.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"></HEAD
><BODY
CLASS="SECTION"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PHPTAL - PHP Template Attribute Language</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="phptal.phptal.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>PHP Integration</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="phptal.filter.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECTION"
><H1
CLASS="SECTION"
><A
NAME="PHPTAL.CACHE"
>interface PHPTAL_Cache</A
></H1
><P
>&#13;As each developper tends to prefer his own cache system and as each user case
is different, PHPTAL does not contains a builtin cache system.&#13;</P
><P
>&#13;Instead, it contains an interface that allow you to work with any existing php
cache system whithin PHPTAL.&#13;</P
><P
>&#13;The interface allow you to cache template results and or macro results in your
own style.&#13;</P
><P
>&#13;The interface resides in PHPTAL_Cache class.&#13;</P
><P
>&#13;Implementations 'may' implements following methods :&#13;</P
><P
></P
><UL
><LI
><P
>&#13;template : called each time a template has to be executed &#13;</P
></LI
><LI
><P
>&#13;macro : called each time a macro has to be executed&#13;</P
></LI
></UL
><P
>&#13;These methods receive some parameters, the first one will be either the
template object or the macro object.&#13;</P
><P
>&#13;The result of the template/macro real execution can be retrieved using :
<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>$macro_or_template-&gt;_process()</I
></SPAN
>.&#13;</P
><P
>&#13;Your cache system must use this method and return the produced string if the
result is not already cached.&#13;</P
><P
>&#13;The way you add a cache manager object to PHPTAL is :&#13;</P
><PRE
CLASS="PROGRAMLISTING"
>$tpl = new PHPTAL('myfile.html');
$tpl-&#62;setCacheManager($myCacheManager);</PRE
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="PHPTAL.CACHE.MACRO"
>method macro</A
></H2
><P
>&#13;This method is called by PHPTAL whenever a macro has to be called. If not
implemented by your cache manager, this method will return the execution of the
macro without cache.&#13;</P
><P
>&#13;Important: A macro level cache system should be aware of macro slots &#13;</P
><P
>&#13;Parameters&#13;</P
><P
></P
><UL
><LI
><P
>&#13;PHPTAL_Macro $macro : the macro object. &#13;</P
></LI
><LI
><P
>&#13;string $file : source path of this macro (may be the path or a
SourceLocator object) &#13;</P
></LI
><LI
><P
>&#13;string $name : the macro name &#13;</P
></LI
><LI
><P
>&#13;PHPTAL_Context $context : the current execution context&#13;</P
></LI
></UL
><P
>&#13;Return&#13;</P
><P
>&#13;string : the cached value or the result of the macro execution&#13;</P
><P
>&#13;Example&#13;</P
><P
>&#13;Idea : you need to cache a big html table resulting of an ugge sql query, tells
the template designer to move the table printing into a macro, get the macro
name and make an implementation of PHPTAL_Cache that will store the macro
output into a file.&#13;</P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN431"
></A
><P
><B
>Example 1. Cache (macro result) implementation</B
></P
><PRE
CLASS="PROGRAMLISTING"
>class MySpecificCache extends PHPTAL_Cache 
{ 
    // 
    // This method is called every time a macro is called. 
    // 
    function macro(&#38;$macro, $file, $name, &#38;$context) 
    { 
        // we only worry about 'mymacro' macro 
        if ($name == 'mymacro') { 
            $cache = '/path/to/cache.txt'; 
            // check that the file exists and the expire time is 
            // not reached 
            if (file_exists($cache) &#38;&#38; (filemtime($cache) + 3600 &#60; time())) { 
                // return the cache content 
                return join('', $cache); 
            }
      
            // not cached yet, let's do it
            // first produce the result 
            $result = $macro-&#62;_process();

            // cache to file 
            $fp = fopen($cache, 'w'); 
            fwrite($fp, $result); 
            fclose($fp);

            // and don't forget to return the result 
            return $result; 
        }
    
        // non handled macro, just process 
        return $macro-&#62;_process(); 
    } 
} </PRE
></DIV
><P
>&#13;When invoking a template object, you can specify the cache manager to use as
follow :&#13;</P
><PRE
CLASS="PROGRAMLISTING"
>require_once "PHPTAL.php";

$tpl = new PHPTAL("some/template.html"); 

$tpl-&#62;set("foo", "bar");
// set template cache manager

$cache = new MySpecificCache(); 
$tpl-&#62;setCacheManager( $cache );

// let's roll 
echo $tpl-&#62;execute();</PRE
><P
>&#13;In the above cache manager exemple, we haven't used the context variable, but
it will be the key for intelligent cache system as it contains the current
template execution context (ie: every variable usuable inside the template,
even defined variables and repeat data).&#13;</P
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="PHPTAL.CACHE.TEMPLATE"
>method template</A
></H2
><P
>&#13;This method is called by PHPTAL whenever a template is to be executed. This
means that any template is subject to the cache system, main one invoqued in
php script as well as tal:included ones.&#13;</P
><P
>&#13;If not implemented by your cache manager, the default behavour of this method
is to return the execution of the template object.&#13;</P
><P
>&#13;Important : a template level cache system should have a way to index its cache
using some variable defined in the context object and may be the template
source path.&#13;</P
><P
>&#13;Parameters&#13;</P
><P
></P
><UL
><LI
><P
>&#13;PHPTAL $tpl : the template object &#13;</P
></LI
><LI
><P
>&#13;string $file : template source file (may comes from SourceLocator) &#13;</P
></LI
><LI
><P
>&#13;PHPTAL_Context $context : the execution context&#13;</P
></LI
></UL
><P
>&#13;Return&#13;</P
><P
>&#13;string : the cached value or the result of the template execution&#13;</P
><P
>&#13;Example&#13;</P
><P
>&#13;We want to cache 'document.html' templates as they contains only 'static' data
retrieved from database. For this exemple, we assume the context contains a
'doc_id' variable.&#13;</P
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN454"
></A
><P
><B
>Example 2. Cache (template result) implementation</B
></P
><PRE
CLASS="PROGRAMLISTING"
>class MySpecificCache extends PHPTAL_Cache 
{ 
    function template(&#38;$tpl, $file, &#38;$context) 
    { 
        // we only worry about 'document.html' templates 
        $str = new OString($file);
        if ($str-&#62;endsWith('/document.html')) { 
            $doc_id = $context-&#62;get('doc_id'); 
            $cache = '/path/to/cached/documents/' . $doc_id;
            // 
            // check that the file exists and that the document 
            // was not modified since the cache occured. 
            // 
            // here we assume Document::lastModified($id) return 
            // the last modification time of specified document id 
            // 
            if (file_exists($cache) 
                &#38;&#38; (filemtime($cache) &#62; Document::lastModified($doc_id)) { 
                // return the cache content 
                return join('', file($cache)); 
            }
            // use this with care, here the document object is not 
            // loaded in the source template, as no cache exists 
            // for it, we load it here and push its reference 
            // in the template context. 
            // 
            // this small concept can prevent your scripts from 
            // executing unrequired queries or actions as their 
            // result is already known and cached somewhere. 
            // 
            $context-&#62;setRef('document', Document::load($doc_id));
            // the template can continue its execution and now it 
            // can access the loaded 'document' object.
            $result = $tpl-&#62;_process();
            // we cache the result 
            $fp = fopen($cache, 'w'); 
            fwrite($fp, $result); 
            fclose($fp);
            // and finally return it 
            return $result; 
        }
        // non handled template 
        return $tpl-&#62;_process(); 
    } 
} </PRE
></DIV
><P
>&#13;An of course an example on how to use this cache system :&#13;</P
><PRE
CLASS="PROGRAMLISTING"
>require_once "PHPTAL.php";

$tpl = new PHPTAL('/template/repository/document.html'); 
$tpl-&#62;set('doc_id', $id);

$cache = new MySpecificCache(); 
$tpl-&#62;setCacheManager($cache);

echo $tpl-&#62;execute();</PRE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="phptal.phptal.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="phptal.filter.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>class PHPTAL</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="phpapi.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>interface PHPTAL_Filter</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>